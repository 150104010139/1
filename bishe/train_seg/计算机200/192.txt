日月 光华   - -   SE 精华区 文章 阅读 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   发信人 :   LiJohn   ( 永久 ) ,   信 区 :   SE 
 标     题 :   [ 转载 ] [ zz ] OOP 语言 技术 比较 ： Java ， C++ ， Object   Pascal         
 发信站 :   日月 光华   ( 2003 年 04 月 10 日 19 : 14 : 31   星期四 ) ,   站 内 信件 
 
 【   以下 文字 转载自   VCL   讨论区   】 
 【   原文 由   aworm   所 发表   】 
 OOP 语言 技术 比较 ： Java ， C++ ， Object   Pascal         
           http : / / www . marcocantu . com 
 本文 将 主要 涉及 三种 面向对象 语言 ： Internet 上 最 流行 的 语言 Java ， 最 常见 的 OOP 语言 C 
 ++ ， 以及 Borland 公司 用于 他们 的 集成 开发 环境 Delphi 中 的 Object   Pascal 。 这 三种 语言 
 具有 很多 相同点 。 本文 将 从 多个 技术 角度 对 这 三种 语言 进行 深入研究 ， 并 逐一 比较 。 至 
 于 哪 一种 语言 最 优秀 ， 我 不想 做过 多 的 评论 ， 这 在 很大 程度 上 取决于 你 究竟 要 做 什么 。 
 
 本文 假定 你 基本 掌握 了 所 涉及 的 三种 语言 中 的 一种 ， 或者 至少 大体上 对 OOP 概念 有 一定 的 
 了解 。 我 将 会 描述 一些 重要 的 语言 特性 ， 然后 我会 对 三种 语言 的 实现 作 一个 比较 。 我 不 
 打算 举 实际 的 例子 ， 我 并 不是 要 教授 OOP ， 只是 比较 这些 语言 。 
 OOP 关键 特性 
 面向对象 程序设计 （ OOP ） 并 不是 一种 新 的 程序设计 技术 。 它 最早 可以 上溯 到 Simula - 67 
 ， 虽然 它 的 第一个 真正 完整 的 实现 是 Simula - 80 。 在 80 年代 下 半期 ， OOP 变得 流行起来 ， 
 并且 出现 了 许多 支持 OOP 的 语言 ， 比如 C++ ， Objective - C （ 另 一种 C语言 扩展 ） ， Object 
   PAscal 和 Turbo   Pascal ， CLOS （ Lisp 的 面向对象 扩展 ） ， Eiffel ， Ada （ 其 最新 的 版本 
 ） ， 以及 最近 的 Java 。 本文 将 集中 讨论 C++ 、 Object   Pascal 和 Java ， 并 有限 的 设计 其它 
 OOP 语言 。 
 OOP 的 关键 特性 是 广为人知 的 ， 在 继续 下面 的 内容 之前 ， 我 将 简单 的 重复 一下 ， 以便 你 再 
 熟悉 一下 这些 通用 技术 。 
 ・ 第一个 关键 特性 是 定义 了 类 ， 封装 了 表现 和 操作 的 抽象数据类型 。 在 OOP 语言 中 ， 类 是 
 模块 、 封装 和 数据抽象 的 基础 。 
 ・ 第二个 关键 特性 是 继承 ， 从 已 存在 的 类型 中 继承 元素 （ 表现 和 方法 ） ， 改变 或 扩展 旧 
 类型 的 方法 。 
 ・ 第三个 关键技术 被 称为 多态性 ， 它 允许 使用 类似 的 方法 操作 不同 类型 的 对象 （ 通常 是 
 子类 对象 ） 。 它 使得 类 的 可用性 进一步提高 ， 程序 也 因此 更 容易 维护 和 扩展 。 
 一种 语言 如果 是 面向对象 的 ， 必须 具有 类 、 继承 和 多态 这 几个 特性 （ 仅 支持 类 而 不 支持 
 继承 和 多态 的 语言 ， 通常 被 称为 基于 对象 的 ） 。 不同 的 OOP 语言 可能 会 使用 完全 不同 的 方 
 法 实现 以上 几个 特性 。 我们 可以 通过 比较 类型 检查 机制 、 对 不同 程序设计 模型 的 支持 以 
 及 所 支持 的 对象 模型 来 区别 不同 的 OOP 语言 。 下面 我 将 深入 语言 特性 的 细节 。 
 编译 期 类型 检查   vs .   运行 期 类型 检查 
 类型 的 强壮 性是 评价 程序设计 语言 的 重要 标准 。 涉及 到 类型 检查 的 内容 包括 对 已 存在 的 
 方法 的 调用 ， 方法 的 参数 的 类型 ， 数组 边界 的 检查 ， 等等 。 
 C++ 、 Java 和 Object   Pascal 多 或多或少 的 支持 编译 期 类型 检查 ， 其中 ， C++ 的 类型 检查 最 
 弱 ， 而 Java 的 最强 。 原因 是 ， C++ 保留 了 对 C语言 的 支持 ， 而 C语言 虽然 支持 编译 期 类型 检 
 查 ， 却 极其 微弱 。 例如 ， C 和 C++ 认为 所有 数字 类型 都 是 兼容 的 （ 虽然 向 整型 变量 赋 浮点 
 数值 时 编译器 会 报警 ） 。 在 Object   Pascal 和 Java 语言 中 ， 布尔值 与 整型 数值 不同 ， 而字 
 符 类型 则 是 另 一个 完全 不 兼容 的 类型 。 
 虽然 Java 虚拟机 在 运行 期 “ 翻译 ” 比特 码 ， 但 并 不 表示 它 放弃 了 编译 期 类型 检查 。 相反 
 ， 在 Java 中 类型 检查 进行 的 相当 彻底 。 另外 一些 OOP 语言 ， 例如 Smalltalk 和 CLOS ， 则 在 
 运行 期 进行 类型 检查 。 
 混合 OOP 语言   vs .   纯 OOP 语言 
 另 一个 区别 存在 于 纯 的 和 混合 的 OOP 语言 之间 。 纯 OOP 语言 只 允许 应用 一种 程序设计 模型 
 ： OOP 。 你 可以 声明 类 和 方法 ， 但 不能 使用 老式 的 普通 函数 、 过程 和 全局变量 。 
 在 以上 三种 语言 中 ， 只有 Java 是 纯 OOP 语言 （ Eiffel 和 Smalltalk 也 是 ） ， 初 看上去 纯 OO 
 P 是 个 很 好 的 主意 ， 然而 ， 你 最终 还是 会 使用 许多 静态方法 和 静态数据 。 除了 语法 更 复杂 
 ， 这 与 使用 全局 函数 和 数据 没有 任何 区别 。 我 个人 的 观点 是 ， 纯 OOP 语言 对于 OOP 的 初学 
 者 非常 有 帮助 ， 因为 他 将 不得不 使用 （ 并 学习 ） 面向对象 程序设计 模型 。 另一方面 ， C + 
 + 和 Object   Pascal 都 是 典型 的 混合 语言 ， 他们 允许 程序员 使用 传统 的 C 或 Pascal 程序设计 
 方法 。 
 要 注意 的 是 ， Smalltalk 大大 扩展 了 纯 面向对象 的 概念 。 在 Smalltalk 中 ， 所有 预定 义数 
 据 类型 ， 例如 整型 、 字符 型 ， 甚至 整个 语言 架构 （ 例如 循环 指令 ） 都 是 以 对象 封装 的 。 
 这 完全 是 出于 对 纯理论 的 兴趣 ， 因为 这样 极大 的 降低 了 程序 的 执行 效率 。 Java 没有 做 得 
 如此 绝对 ， 它 允许 使用 传统 的 ， 非 面向对象 的 数据类型 （ 虽然 它 提供 了 对 传统 类型 的 类 
 封装 ） 。 
 普通 对象 模型   vs .   对象 引用 模型 
 OOP 语言 之间 存在 的 第三个 主要 区别 在于 它们 的 对象 模型 。 一些 比较 传统 的 OOP 语言 允许 
 程序员 在 栈 、 堆 和 静态 存储 区中 创建对象 。 在 这些 语言 中 ， 一个 类 的 变量 （ 实例 ） 对应 
 于 内存 中 的 一个 对象 。 C++ 就是 这样 工作 的 。 
 之后 的 OOP 语言 倾向 于 使用 另 一种 模型 ， 称为 对象 引用 模型 。 在 这个 模型 中 ， 每个 对象 都 
 动态 的 创建 于 堆 中 ， 一个 类 的 变量 实际上 是 一个 指向 内存 中 的 对象 的 引用 或 句柄 （ 技术 
 上 类似 于 指针 的 某种 东西 ） 。 Java 和 Object   Pascal 都 采用 了 这种 引用 模型 。 我们 很快 就 
 会 看到 ， 采用 这种 模型 你 必须 记得 为 对象 分配内存 。 
 类 、 对象 和 引用 
 ・ 特性 描述 ： 在 介绍 了 以上 内容 后 ， 我们 进入 对 OOP 语言 的 讨论 。 最好 的 起点 是 类 和 对象 
 。 我 希望 每个 人 都 清楚 的 明白 这 两个 名词 的 区别 ， 简言之 ， 一个 类 是 一种 数据类型 ， 而 
 一个 对象 则 是 某个 类 的 实例 。 现在 我们 来 看看 如何 在 基于 不同 对象 模型 的 OOP 语言 中 使用 
 对象 。 
 ・ C++ ： 在 C++ 中 ， 假设 有 一个 类 MyClass ， 这个 类有 一个 方法 MyMethod ， 我们 可以 写出 如 
 下 代码 ： 
     MyClass   Obj ; 
     Obj . MyMethod ; 
 这样 就 创建 了 一个 名为 Obj 的 MyClass 类 。 通常 C++ 会 在 栈 中 为 这个 对象 分配内存 空间 。 现 
 在 就 可以 像 第二行 代码 那样 使用 对象 了 。 
 ・ Java ： 在 Java 中 ， 类似 的 语句 只 为 指向 对象 的 句柄 分配内存 ， 而 不是 为 对象 本身 ： 
     MyClass   Obj ; 
     Obj   =   new   MyClass ( ) ; 
     Obj . MyMethod ( ) ; 
 在 你 使用 对象 之前 ， 必须 使用 “ new ” 为 对象 分配内存 。 当然 ， 最好 在 同 一条 语句 中 声明 
 并 初始化 对象 ， 以 避免 使用 未 被 初始化 的 对象 句柄 ： 
     MyClass   Obj   =   new   MyClass ( ) ; 
     Obj . MyMethod ( ) ; 
 ・ OP ： Object   Pascal 采用 大致相同 的 方法 ， 但是 必须 在 不同 的 语句 中 声明 和 初始化 对象 
 ： 
     var 
         Obj :   MyClass ; 
     begin 
         Obj   : =   MyClass . Create ; 
         Obj . MyMethod ; 
 ・ 注意 ： 虽然 对象 引用 模型 似乎 需要 程序员 写 更 多 的 代码 ， 但 要 知道 ， 在 C++ 中 经常 需要 
 使用 对象 的 指针 和 引用 （ 例如 只有 使用 指针 或 引用 ， 才能 获得 多态性 能 ） 。 而 在 对象 引 
 用 模型 中 ， 指针 被 默认 使用 ， 但 却 被 巧妙 的 隐藏 起来 。 特别 是 Java 中 并 没有 正式 的 指针 
 ， 而 事实上 ， 指针 无处不在 。 只不过 程序员 不能 直接 控制 这些 指针 ， 但 也 因此 他们 不会 
 随机 访问 内存地址 ， 从而 使 程序 更加 安全 。 
 回收 
 ・ 特性 描述 ： 一旦 你 创建 并 使用 了 一个 对象 ， 就 需要 销毁 它 ， 以 避免浪费 内存 资源 。 
 ・ C++ ： 在 C++ 中 销毁 一个 储存 在 栈 中 的 对象 是 十分 容易 的 。 另一方面 ， 要 销毁 动态创建 
 的 对象 就 困难 多 了 。 有 很多 解决办法 ， 例如 引用 计数 和 智能 指针 ， 但是 这样 增加 了 复杂 
 程度 。 C++ 程序员 的 第一印象 是 使用 引用 对象 模型 来 解决问题 实在 是 太 糟 了 。 
 ・ Java ： 对于 Java 来说 ， 这是 小事一桩 ， 因为 虚拟 机会 在 后台 运行 碎片 收集 程序 。 这使 
 得 程序员 轻松 不少 。 但 在 另一方面 ， 这 也 影响 了 应用程序 的 执行 效率 。 如果 没有 编写 析 
 构器 ， 可能 会 在 清除 代码执行 时 导致 一个 逻辑 错误 。 
 ・ OP ： 在 Object   Pascal 中 ， 没有 类似 的 碎片 收集 机制 。 但是 Delphi 组件 支持 一种 新 概念 
 ， 属主 对象 。 属主 对象 将 对 所有 下属 组件 的 销毁 负责 。 这 就 使 对象 销毁 变得 简单明了 。 
 
 定义新 的 类 
 ・ 特性 描述 ： 我们 已经 了解 了 如何 创建 已 存在 的 类 的 实例 （ 对象 ） ， 我们 新 的 议题 是 类 
 的 定义 。 简单 说来 ， 一个 类 是 一个 方法 的 集合 ， 而 方法 是 定义 在 一些 局部 数据 上 的 操作 
 。 
 ・ C++ ： 下面 是 一个 简单 类 的 C++ 定义 ： 
     class   Date   { 
         private : 
             int   dd ; 
             int   mm ; 
             int   yy ; 
         public : 
             void   Init ( int   d ,   int   m ,   int   y ) ; 
             int   Day ( ) ; 
             int   Month ( ) ; 
             int   Year ( ) ; 
     } ; 
 下面 是 其中 一个 方法 的 定义 ： 
     void   Date : : Init ( int   d ,   int   m ,   int   y ) 
     { 
         dd   =   d ; 
         mm   =   m ; 
         yy   =   y ; 
     } 
 ・ Java ： Java 的 语法 与 C++ 语法 类似 ： 
     class   Date   { 
         int   dd   =   1 ; 
         int   mm   =   1 ; 
         int   yy   =   1 ; 
         publlic   void   Init ( int   d ,   int   m ,   int   y )   { 
             dd   =   d ;   mm   =   m ;   yy   =   y ;   } 
         public   int   Day   ( )   {   return   dd ;   } 
         public   int   Month   ( )   {   return   mm ;   } 
         public   int   Year   ( )   {   return   yy ;   } 
     } 
 两者之间 最大 的 不同 在于 Java 的 方法 代码 在 声明 的 同时 就 定义 了 （ 与 C++ 不同 ， 这 并 不表 
 示 这些 函数 是 内联 函数 ） ， 并且 可以 同时 初始化 类 的 数据 成员 。 事实上 ， 如果 你 没有 初 
 始化 这些 数据 成员 ， Java 会 将 所有 数据 成员 初始化 为 默认值 。 
 ・ OP ： 在 Object   Pascal 的 类 声明 语法 更 接近 C++ 语法 ， 但是 仍 有 很多 区别 ： 
     type 
         Date   =   class 
         private 
             dd ,   mm ,   yy :   Integer ; 
         public 
             procedure   Init   ( d ,   m ,   y :   Integer ) ; 
             function   Month :   Integer ; 
             function   Day :   Integer ; 
             function   Year :   Integer ; 
         end ; 
     procedure   Date . Init   ( d ,   m ,   y :   Integer ) ; 
     begin 
         dd   : =   d ; 
         mm   : =   m ; 
         yy   : =   y ; 
     end ; 
     function   Date . Day :   Integer ; 
     begin 
         Result   : =   dd ; 
     end ; 
 你 可能 注意 到 一些 语法 上 的 区别 ： 定义方法 使用 两个 不同 的 关键字 function 和 procedur 
 e ， 没有 参数 的 方法 不 使用 圆括号 ， 方法 在 类 定义 中 声明 ， 之后 再作 定义 （ 就 像 C++ 中 经 
 常 遇到 的 情况 一样 ） 。 注意 ， Pascal 使用 点 运算符 ， 而 C++ 使用 作用域 操作符 （ : : ） 。 
 ・ 注意 ： 访问 当前 对象 。 OOP 语言 的 方法 与 全局 函数 不同 ， 它 包含 了 一个 隐藏 参数 ― ― 一 
 个 指向 当前 被 操作 对象 的 指针 或 引用 。 在 不同 的 语言 中 ， 这个 参数 的 名字 不同 ， 在 C++ 和 
 Java 中是 this ， 在 Object   Pascal 中是 self 。 
 构造函数 （ constructor ） 
 ・ 特性 描述 ： 上文 所述 的 类 实在 太 简单 了 。 为了 解决 对象 初始化 的 问题 ， 我们 要 为 类增 
 加 一个 构造函数 ， 这 也 是 改进 类 所 需 迈出 的 第一步 。 
 ・ C++ ： 在 C++ 以及 Java 中 ， 构造函数 和 类 具有 相同 的 名字 。 如果 你 没有 定义 构造函数 ， 
 编译器 会 自动 为类 添加 一个 默认 构造函数 。 在 这 两种 语言 中 ， 你 的 类 可以 具有 多个 构造 
 函数 ， 这要 感谢 “ 方法 重载 ” 。 
 ・ Java ： 在 Java 中 ， 虽然 构造函数 也 被 称为 初始化 函数 （ initializer ） ， 但 与 C++ 的 构 
 造 函数 在 使用 上 没有 什么 区别 。 需要 注意 的 是 ， Java 虚拟机 负责 创建对象 ， 而 构造函数 
 只 对 创建 的 对象 进行 初始化 （ Object   Pascal 也 有 类似 的 情况 ） 。 
 ・ OP ： 在 Object   Pascal 中 ， 构造函数 以 一个 特殊 的 关键字 ― ― constructor 声明 。 在 OP 
 中 没有 方法 重载 （ ？ ， 没有 吗 ？ ― ― 译者 ） ， 不过 因为 构造函数 （ 在 Delphi 的 书 中 通常 
 成为 构造 器 ― ― 译者 ） 的 名字 可以 任意 指定 ， 所以 你 可以 提供 几个 名字 不同 的 构造函数 
 。 OP 中 每个 类 都 有 默认 的 构造函数 “ Create ” ， 除非 你 用 名字 相同 而 参数 不同 的 构造 函 
 数将 其 覆盖 。 这个 构造函数 继承 自 一个 通用 基类 ， 下面 我们 会 提到 。 
 析构 函数 和 finalize ( ) 
 ・ 特性 描述 ： 析构 函数 扮演 了 构造函数 反面 的 角色 ， 通常 在 对象 销毁 时 被 调用 。 如果说 
 大多数 类 都 需要 构造函数 ， 那么 只有 很少 的 类 需要 析构 函数 。 一个 析构 函数 的 基本功能 
 就是 释放 构造函数 （ 以及 对象 生存期 中 的 其它 方法 ） 分配 的 资源 。 这些 资源 包括 内存 、 
 文件 、 数据库 表 、 Windows 句柄 ， 等等 。 
 ・ C++ ： C++ 的 析构 函数 在 对象 超出 作用域 时 ， 或者 删除 动态 创建对象 时 自动 被 调用 。 每 
 个类 只能 由 一个 析构 函数 。 
 ・ OP ： Object   Pascal 的 析构 函数 与 C++ 的 析构 函数 类似 。 Object   Pascal 使用 标准 虚拟 析 
 构 函数 ， 称为 “ Destroy ” 。 析构 函数 通过 标准 “ Free ” 方法 调用 。 因为 所有 对象 都 是 动 
 态 创建 的 ， 所以 你 或者 对象 的 属主 必须 调用 对象 的 析构 函数 ， 以 释放 资源 。 理论 上 你 可 
 以 定义 多个 析构 函数 ， 不过 只有 你 手动 调用 析构 函数 才 有些 价值 （ 没有 什么 是 自动 完成 
 的 ） 。 
 ・ Java ： Java 没有 析构 函数 。 没有 引用 的 对象 将 被 碎片 回收 程序 在 后台 销毁 。 在 销毁 对 
 象 之前 ， 碎片 回收 程序 调用 finalize ( ) 方法 。 但是 ， 并 没有 什么 保证 这个 函数 真正 被 调 
 用 （ 至少 在 Java   1.0 中时 是 这样 ） 。 因此 ， 如果 你 需要 释放 资源 ， 你 就要 定义 一个 方法 
 ， 并 保证 它 被 调用 。 
 类 封装 （ Private 和 Public ） 
 ・ 特性 描述 ： 这 三种 语言 提供 了 相同 的 三种 访问 限定符 来 提供 不同 级别 的 类 封装 ： publ 
 ic ， protected 和 private 。 public 意味着 对于 任何 类 都 是 可见 的 ， protected 意味着 对于 
 派生类 可见 ， private 意味着 没有 外部 可见 性 。 但是 三种 语言 的 实现 细节 并不相同 。 
 ・ C++ ： 在 C++ 中 ， 你 可以 使用 friend 关键字 跳出 类 封装 。 由 class 关键字 声明 的 类 默认 可 
 见性 是 private ， 由 struct 关键字 声明 的 类 默认 可见 性是 public 。 
 ・ OP ： 在 Object   Pascal 中 ， private 和 protected 关键字 只 对 在 不同 单元 中 的 类 有 作用 。 
 在 同一 单元 （ 源代码 文件 ） 声明 的 类 彼此之间 可以 自由 访问 。 Delphi 还有 两个 特殊 的 访 
 问 限定符 ： published 和 automated 。 published 将 为 类 的 成员 建立 RTTI （ 运行 期 类型信息 
 ） ， automated 用于 OLE 自动化 接口 （ 已 废弃 ― ― 译者 ） 。 
 ・ Java ： 在 Java 中 ， 一个 语法 上 的 区别 是 每 一个 类 成员 都 要 用 访问 限定符 声明 。 另 一个 
 实质 上 的 区别 是 ， Java 中类 成员 默认 访问 限定符 是 friendly ， 因此 对 同一个 包 （ 源代码 
 文件 ， 类似 于 OP 的 单元 ） 中 的 所有 类 都 是 可见 的 。 同样 ， protected 关键字 表示 类 成员 对 
 派生类 可见 ， 同时 也 对 同一个 包中 的 其它 类 可见 ， 而 private   protected 才 对应 于 C++ 中 
 的 protected 。 
 文件 、 单元 和 包 
 ・ 特性 描述 ： 这 三种 语言 的 一个 重要 区别 是 对 源代码 文件 的 组织 管理 。 它们 都 使用 文件 
 作为 储存 源代码 的 标准 机构 （ 与 其它 OOP 语言 如 Smalltalk 不同 ） ， 不同 的 是 C++ 的 编译器 
 并 不 真正 了解 文件 ， 而 OP 和 Java 则 不同 ， 它们 使用 模块 概念 来 管理文件 ， 虽然 各自 的 名 
 字 不 太 一样 。 
 ・ C++ ： 在 C++ 中 ， 程序员 们 一般 把 类 定义 放在 头文件 中 ， 而 把 方法 实现 放入 独立 的 代码 
 文件 。 通常 这 两个 文件 会 具有 相同 的 文件名 和 不同 的 扩展名 。 一个 编译 单元 应该 包括 它 
 自己 的 声明 文件 及其 代码 所 涉及 的 类 及 函数 的 声明 文件 。 但 这 仅仅 是 惯例 ， 编译器 并 不 
 强迫 这样 做 。 链接 器 将 不得不 做 更 多 的 工作 ， 因为 编译器 无法 预料 一个 方法 是否 在 某个 
 模块 中 被 定义 。 
 ・ OP ： 在 Object   Pascal 中 ， 源代码 文件 被 称为 单元 （ unit ） 。 单元 被 分为 接口 （ inter 
 face ） 和 实现 （ implementation ） 两 部分 。 接口 部分 包含 了 类 的 定义 （ 包括 方法 的 声明 
 ） ， 实现 部分 则 包含 了 声明 于 接口 部分 的 方法 的 定义 。 在 接口 中 编写 执行 代码 是 非法 的 
 。 你 可以 使用 uses 子句 包含 其它 文件 ， 以便 引用 其中 声明 的 类 、 方法 等等 。 下面 的 代码 
 包含 了 一些 编译 单元 的 接口 ： 
 uses 
     Windows ,   Form ,   MyFile ; 
 ・ Java ： 在 Java 中 ， 每个 源代码 文件 ， 或者说 编译 单元 之间 是 完全 独立 的 。 你 可以 把 一 
 组 编译 单元 作为 一个包 的 一部分 。 与 其它 两种 语言 不同 ， 在 声明 类 的 同时 要 编写 方法 实 
 现 的 代码 。 当 使用 import 子句 包含 一个 文件 时 ， 编译器 只读 入 它 的 public 声明 ， 而 不是 
 所有 的 代码 ： 
 import   where . myclass ; 
 import   where . *   / /   all   the   classes 
 ・ 注意 ： 关于 被 称为 名字 空间 的 模块 。 另 一个 关键性 的 区别 是 Java 和 OP 的 编译器 可以 读 
 入 一个 已 编译 文件 ， 并 从中 提取 它 的 定义 ， 就 像 你 从 已 编译 代码 中 提取 头文件 一样 。 另 
 一方面 ， C++ 语言 引用 名字 空间 （ namespace ） 来 弥补 没有 模块 结构 的 不足 。 在 Java 和 OP 
 中 ， 事实上 ， 通常 以 模块 的 名字 为 前缀 来 解决 名字 之间 的 冲突 。 使用 名字 空间 也 可以 达 
 到 同样 的 效果 ， 不过 它 是 内建 在 语言 中 的 。 
 类 / 静态方法 和 数据 成员 
 ・ 特性 描述 ： 通常 OOP 语言 允许 某些 方法 和 数据 成员 与 整个 类 相关 ， 而 不是 对象 个体 。 一 
 般的 类 方法 可以 通过 类 的 单个 对象 或类 调用 。 类 数据 成员 是 被 所有 对象 共享 的 数据 成员 
 ， 而 不是 为 每个 对象 单独 创立 。 
 ・ C++ ： 在 C++ 中 ， 类 方法 和 类 数据 成员 以 static 关键字 声明 。 类 数据 成员 必须 使用 一个 
 特殊 的 声明 来 初始化 ， 这是 缺少 模块 结构 的 不足 之一 。 
 ・ OP ： OP 中 只有 类 方法 ， 使用 class 关键字 声明 。 而 定义 于 同一 单元 中 的 私有 全局变量 可 
 以 发挥 类 数据 成员 的 作用 。 
 ・ Java ： Java 使用 和 C++ 相同 的 关键字 static 。 静态方法 经常 被 使用 （ 甚至 有些 过分 ） ， 
 这 是因为 在 Java 中 没有 全局 函数 。 静态数据 成员 可以 直接 在 类 声明 中 初始化 。 
 类 和 继承 
 ・ 特性 描述 ： 类 的 继承 是 OOP 的 根基 之一 。 它 可以 用来 做 一般化 表述 和 特殊化 表述 。 关于 
 继承 的 基础 思想 是 通过 修改 或 扩展 现存 的 类型 建立 新 的 类型 ， 换句话说 ， 一个 派生类 具 
 有 基类 的 所有 数据 成员 和 方法 ， 并 添加 了 新 的 数据 成员 和 方法 ， 还有 可能 修改 某些 以存 
 在 的 方法 。 不同 的 OOP 语言 用 不同 的 名词 描述 这种 机制 （ derivation ， inheritance ， su 
 bclassing ） 、 被 继承 的 类 （ 基类 ， 父类 ， 超类 ） 和 继承 的 类 （ 派生类 ， 子类 ， 次类 ) 。 
 
 ・ C++ ： C++ 使用 public 、 protected 和 private 关键字 定义 继承 的 方式 ， 改变 继承 的 方法 
 和 数据 成员 的 访问 限定 类型 。 虽然 public 继承 最常 被 使用 ， 但 在 C++ 中 默认 的 是 private 
 继承 。 C++ 是 这 三种 语言 中 唯一 允许 多重 继承 的 语言 ， 以后 我们 还会 提到 。 下面 是 一个 例 
 子 ： 
 class   Dog :   public   Animal   { 
 ... 
 } ; 
 ・ OP ： Object   Pascal 使用 一个 特殊 的 语法 表述 继承 ， 而 不是 使用 关键字 ， 方法 是 将 基类 
 名 放入 括号 中 ， 添加 到 类 声明 中 。 OP 只 支持 C++ 中 所谓 public 的 继承 。 OP 类 具有 一个 通用 
 基类 ， 以后 我们 会 见到 。 
 type 
     Dog   =   class   ( Animal ) 
         ... 
     end ; 
 ・ Java ： Java 使用 extends 关键字 来 表述 唯一 一种 继承 类型 ， 对应 于 C++ 中 的 public 继承 
 。 Java 不 支持 多重 继承 。 Java 类 同样 具有 一个 通用 基类 。 
 class   Dog   extends   Animal   { 
 ... 
 } 
 ・ 注意 ： 关于 基类 的 构造函数 和 初始化 。 在 C++ 和 Java 中 ， 基类 的 构造函数 具有 很 复杂 的 
 结构 。 在 OP 中 ， 初始化 基类 则 是 程序员 的 责任 。 这个 主题 比较复杂 ， 所以 我 不 打算 进一 
 步 讲述 。 我会 把 注意力 集中 在 通用 基类 、 基类 访问 、 多重 继承 、 接口 、 后期 绑定 以及 其 
 它 相关 的 内容 。 
 所有 类 的 祖先 
 ・ 特性 描述 ： 在 一些 OOP 语言 中 ， 所有 类 都 直接 或 间接 的 派生 自 某个 特定 的 基类 。 这个 类 
 （ 通常 被 称为 Object 或 其它 类似 的 名字 ） 具有 所有 类 共有 的 基本功能 。 事实上 ， 所有 类 
 都 继承 自 这个 基类 。 因为 最初 在 Smalltalk 中 便是 如此 设计 的 ， 所以 大多数 OOP 语言 采用 
 了 这个 概念 。 
 ・ C++ ： 虽然 在 C++ 中 没有 这个 概念 ， 但 许多 应用程序 框架 引入 了 通用 基类 的 概念 。 MFC 是 
 个 很 好 的 例子 ， 它 有 一个 CObject 类 。 事实上 ， 最初 这是 十分 意义 的 ， 因为 语言 不 具有 模 
 板 特性 （ 以及 多重 继承 特性 ） 。 
 ・ OP ： 每个 类 都 自动 的 继承 自 TObject 类 。 因为 OP 不 支持 多重 继承 ， 所以 所有 的 类 构成 了 
 一个 巨大 的 派生 树 。 TObject 类 可以 处理 RTTI ， 同时 具有 其它 一些 能力 。 
 ・ Java ： 如同 OP 一样 ， 所有 的 类 继承 自 Object 类 。 这个 基类 也 具有 一些 有限 的 功能 。 
 访问 基类 的 方法 
 ・ 特性 描述 ： 当 编写 一个 类 方法 或者 重载 一个 基类 方法 时 ， 你 经常 需要 引用 基类 的 方法 
 。 而 如果 方法 在 派生类 中 重新 被 定义 ， 那么 使用 方法 的 名字 将 调用 新 方法 。 OOP 语言 使用 
 不同 的 技术 或 关键字 解决 访问 基类 方法 的 问题 。 
 ・ C++ ： 在 C++ 中 可以 使用 范围 操作符 （ : : ） 引用 一个 特定 的 类 。 你 不仅 可以 访问 基类 ， 
 甚至 可以 访问 继承 链中 更 高层 的 类 。 
 ・ OP ： Object   Pascal 使用 一个 特殊 的 关键字 完成 同样 的 工作 ： inherited 。 在 关键字 后 
 可以 加上 需要 调用 的 基类 方法 的 名称 ， 或者 （ 在 某些 情况 下 ） ， 简单 的 使用 这个 关键字 
 来 访问 对应 的 基类 方法 。 
 ・ Java ： Java 中 使用 super 关键字 完成 类似 的 工作 。 在 Java 和 OP 中 ， 你 无法访问 更高 一级 
 的 基类 。 看起来 这 似乎 限制 了 什么 ， 但是 这样 可以 通过 添加 中间 类来 扩展 继承 链 。 同时 
 ， 如果 你 不 需要 基类 的 功能 ， 你 也许 可以 不 从 这个 基类 派生 你 的 新类 。 
 子类 兼容性 
 ・ 特性 描述 ： 并 不是 所有 OOP 语言 都 是 强 类型 的 ， 就 像 我 开始 提到 的 ， 但是 这里 我们 涉及 
 的 三种 语言 都 是 。 这 意味着 不同 类 的 对象 之间 是 不 兼容 的 。 只有 一个 例外 ， 就是 派生类 
 的 对象 与 基类 是 兼容 的 （ 注意 ： 反过来 不 成立 ） 。 
 ・ C++ ： 在 C++ 中 ， 子类 兼容性 规则 只 适用 于 指针 和 引用 ， 对 普通 对象 则 不 适用 。 事实上 
 ， 不同 的 对象 在 所 占用 的 内存 不同 ， 所以 你 不能 将 相同 的 内存 分配 给 不同 的 对象 。 
 ・ OP ： 子类 兼容性 适用 于 所有 对象 ， 因为 OP 采用 了 对象 参考模型 。 此外 ， 所有 对象 都 与 
 TObject 类型 兼容 。 
 ・ Java ： Java 的 情况 与 OP 完全相同 。 
 ・ 注意 ： 多态性 。 如同 下 一节 将要 描述 的 ， 子类 兼容性 对于 实现 后期 绑定 和 多态性 是 十 
 分 重要 的 。 
 后期 绑定 （ 及 多态性 ） 
 ・ 特性 描述 ： 当 继承 链中 不同 的 类 分别 重新 定义 了 它们 基类 的 方法 ， 那么 如果 能够 通过 
 一个 兼容 这些 类 的 对象 （ 感谢 子类 兼容性 ） 调用 合适 的 类 的 方法 ， 将 是 十分 有用 的 。 要 
 完成 这个 工作 ， 编译器 需要 支持 后期 绑定 ， 它 将 不 产生 一个 特定 的 函数调用 ， 而是 在 运 
 行期 决定 了 对象 的 真正 类型 后 ， 才 进行 函数调用 。 
 ・ C++ ： 在 C++ 中 ， 后期 绑定 只 应用 于 虚拟 方法 （ 在 调用 速度 上 会 有所 减慢 ） 。 一个 在 基 
 类中 定义 的 虚拟 方法 将 在 它 被 重新 定义 时 保持 这种 特性 （ 当然 方法 的 声明 必须 完全 匹配 
 ） 。 一般 情况 ， 非 虚拟 方法 并 不 允许 后期 绑定 。 
 ・ OP ： 在 Object   Pascal 中 ， 后期 绑定 通过 关键字 virtual 或 dynamic 引入 （ 这 两个 关键字 
 的 区别 仅 在于 技术 实现 的 不同 ） 。 在 派生类 重新 定义方法 时 ， 应 使用 override 关键字 （ 
 这样 就 强迫 编译器 检查 方法 声明 是否 匹配 ） 。 这是 OP 中 特有 的 ， 它 允许 在 基类 做 更 多 的 
 改动 。 
 ・ Java ： 在 Java 中 ， 所有 的 方法 都 使用 后期 绑定 ， 除非 你 使用 final 关键字 。 final 方法 
 不能 被 重新 定义 ， 在 调用 速度 上 更 快 。 在 Java 中 正确 的 方法 名称 对于 多态性 的 实现 是非 
 常 重要 的 。 Java 中 默认 后期 绑定 和 C++ 中 默认 前期 绑定 这一 事实 表明 了 这 两种 语言 不同 的 
 针对性 ： C++ 有时 会 牺牲 OOP 模型 以 获取 性能 的 提升 。 
 ・ 注意 ： 构造函数 和析构 函数 的 后期 绑定 。 与 其它 两种 语言 相反 ， Object   Pascal 允许 定 
 义 虚拟 构造函数 。 而 这 三种 语言 都 支持 虚拟 析构 函数 。 
 抽象 方法 和 抽象类 
 ・ 特性 描述 ： 当 建立 一个 复杂 的 继承 链时 ， 为了 实现 多态性 ， 经常 需要 为 更 高级 的 类 引 
 入 一些 方法 ， 虽然 这些 方法 未必 是 为 这个 类 抽象概念 而 定义 的 。 除了 使用 空 方法 定义 ， 
 许多 OOP 语言 实现 了 一种 特殊 的 机制 ： 定义 抽象 方法 。 所谓 抽象 方法 就是 没有 实现 的 方法 
 。 具有 一个 或 多个 抽象 方法 的 类 称为 抽象类 。 
 ・ C++ ： 在 C++ 中 ， 抽象 方法 被 称为 纯虚 函数 ， 通过 在 方法 定义 后 添加 所谓 虚 定义 符 （ = 0 
 ） 可以 获得 一个 抽象 方法 。 抽象类 就是 具有 （ 或 继承 了 ） 一个 或 多个 抽象 方法 的 类 。 不 
 能 创建 抽象类 对象 。 
 ・ OP ： Object   Pascal 使用 abstract 关键字 声明 抽象 方法 。 同样 ， 抽象类 就是 具有 或 继承 
 了 抽象 方法 的 类 ， 但是 你 可以 创建 抽象类 的 实例 （ 虽然 编译器 会 产生 一个 警告 信息 ） 。 
 这 就 隐含 了 调用 抽象 方法 的 危险 ， 在 运行 期 ， 这样 会 产生 一个 运行 期 错误 ， 并会 终止 程 
 序 的 运行 。 
 ・ Java ： 在 Java 中 ， 抽象 方法 和 抽象类 都 用 abstract 关键字 声明 （ 事实上 Java 中 的 抽象 
 类 必须 具有 抽象 方法 ， 好像 有 一点 多余 ） 。 同样 ， 派生类 如果 没有 重新 定义 所有 的 抽象 
 方法 ， 必须 使用 abstract 关键字 定义 为 抽象类 。 不能 创建 抽象类 的 实例 。 
 多重 继承 和 接口 
 ・ 特性 描述 ： 一些 OOP 语言 允许 从 多个 基类 派生 新类 。 另 一些 语言 只 允许 从 一个 类中 派生 
 新类 ， 但是 可以 从 多个 接口 （ 或者 纯 抽象类 ， 只 由 纯虚 函数 构成 的 类 ） 派生 新类 。 
 ・ C++ ： C++ 是 三种 语言 中 唯一 支持 多重 继承 的 。 一些 程序员 认为 这是 一件 好事 ， 另 一些 
 程序员 认为 这是 一件 坏事 ， 我 不想 过多 的 讨论 这个 问题 。 多重 继承 产生 了 很多 新 概念 ， 
 比如说 虚 基类 ， 虽然 功能强大 ， 但 并 不好 掌握 。 C++ 没有 接口 的 概念 ， 虽然 它 与 多重 继承 
 的 纯 抽象类 概念 接近 （ 接口 可以 看作 多重 继承 的 子集 ） 。 
 ・ Java ： Java ， 以及 Object   Pascal ， 都 不 支持 多重 继承 ， 但是 完全 支持 接口 。 接口 的 方 
 法 支持 多态性 ， 并且 当 需要 一个 接口 对象 时 ， 可以 通过 一个 对象 实现 接口 。 一个 类 只能 
 继承 自 一个 基类 ， 但 可以 implement （ 关键字 ） 多个 接口 。 Java 的 接口 与 COM 模型 非常 吻 
 合 ， 虽然 没有 预先 的 考虑 。 举个 例子 ： 
 public   interface   CanFly   { 
 public   void   Fly ( ) ; 
 } 
 public   class   Bat   extends   Animal   implements   CanFly   { 
 public   void   Fly (   )   {   / /   the   bat   flies ...   } 
 } 
 ・ OP ： Delphi   3 在 Object   Pascal 中 引入 了 类似 Java 的 接口 ， 这些 接口 非常 吻合 COM （ 虽 
 然 技术 上 经常 在 非 COM 程序 中 使用 ） 。 接口 构造 了 一个 与 类 独立 的 继承 链 ， 但是 与 Java 一 
 样 ， 一个 类 可以 继承 自 唯一 的 基类 并 实现 多个 接口 。 将类 的 方法 映射 为类 实现 的 接口 的 
 方法 是 Object   Pascal 语言 中 令人 迷惑 的 几个 问题 中 的 一个 。 
 RTTI 
 ・ 特性 描述 ： 在 强 类型 OOP 语言 中 ， 编译器 完成 所有 类型 检查 的 工作 ， 所以 很少 需要 运行 
 程序 保存 类型 的 信息 。 然而 ， 某些 情况 下 需要 某些 类型信息 。 因此 ， 这 三种 OOP 语言 都 或 
 多 或 少 的 支持 运行 期 类型 识别 / 信息 （ RTTI ） 。 
 ・ C++ ： 最初 的 C++ 语言 不 支持 RTTI 。 后来 通过 dynamic _ cast 的 方式 提供 了 部分 的 类型 信 
 息 。 你 可以 查询 一个 对象 的 类型 ， 也 可以 检查 两个 对象 是否 具有 相同 的 类型 。 
 ・ OP ： Object   Pascal 以及 它 的 可视 开发 环境 支持 也 需要 大量 的 RTTI 。 不仅 可以 进行 类型 
 检查 （ 使用 is 和 as 操作符 ） ， 类 也 为 它 的 published 成员 生成 大量 的 RTTI 。 事实上 这个 关 
 键字 负责 部分 RTTI 的 生成 。 属性 、 流 结构 （ 窗体 文件 以及 始于 对象 观察器 的 Delphi 环境 
 很大 程度 上 依赖于 类 的 RTTI 。 TObject 类 具有 ClassName 和 ClassType 方法 。 ClassType 方 
 法 返回 一个 类 类型 变量 ― ― 一个 特殊 类 参考 类型 的 实例 （ 并 不是 类 本身 ） 。 
 ・ Java ： 和 Object   Pascal 一样 ， Java 中 也 有 一个 基类 用于 跟踪 类型信息 。 Object 类 的 g 
 etClass ( ) 方法 会 返回 一个 元类 （ 一个 用于 描述 类 的 类型 的 对象 ） ， 你 也 可以 使用 getNa 
 me ( ) 函数 获得 一个 类名 字符串 。 你 还 可以 使用 instanceof 操作符 。 Java   1.0 不 支持 更 多 
 内容 的 RTTI ， 但 在 未来 的 版本 中 可能 会 改变 ， 以 适应 可视 环境 和 组件 的 开发 （ 所谓 Java 
   Beans ） 。 
 ・ 例子 ： 
 / /   C++ 
 Dog *   MyDog   =   dynamic _ cast   < Dog * >   ( myAnimal ) ; 
 / /   Java 
 Dog   MyDog   =   ( Dog )   myAnimal ; 
 / /   Object   Pascal 
 Dog   myDog   : =   myAnimal   as   Dog ; 
 异常 处理 
 ・ 特性 描述 ： 异常 处理 构想 的 出发点 是 简化 程序 的 错误处理 代码 ， 提供 标准 内 建 机制 ， 
 从而 使 程序 更加 健壮 。 异常 处理 的 内容 很多 ， 这里 我 只是 简述 一些 关键 的 要素 和 区别 。 
 
 ・ C++ ： C++ 使用 throw 关键字 来 产生 一个 异常 ， 用 try 关键字 标志 被 保护 的 程序 块 ， 用 ca 
 tch 关键字 标志 异常 处理 程序代码 。 异常 是 一些 特殊 类 的 对象 ， 在 这 三种 语言 中 都 构成 了 
 各自 的 继承 链 。 C++ 会 对 所有 栈中 的 对象 进行 栈 展开 和 销毁 （ 调用 析构 函数 ） 。 
 ・ OP ： Object   Pascal 使用 与 C++ 类似 的 关键字 raise ， try 和 except ， 并且 具有 类似 的 功 
 能 。 唯一 真正 的 区别 是因为 没有 对象 会 被 创建 于栈 中 ， 所以 不会 发生 栈 展开 。 另外 ， 你 
 可以 使用 一个 finally 关键字 ， 标志 那些 无论 是否 产生 异常 都 被 执行 的 代码 。 在 Delphi 中 
 ， 异常 类 全部 派生 自 Exception 。 
 ・ Java ： Java 使用 和 C++ 相同 的 关键字 ， 但是 其 行为 却 更 接近 于 Object   Pascal ， 包括 使 
 用 finally 关键字 。 所有 采用 对象 引用 模型 的 语言 基本 都 是 如此 。 碎片 回收 程序 的 存在 限 
 制 了 finally 关键字 对类 的 应用 ， 这些 类 不仅 占用 了 内存 资源 。 Java 认为 所有 能 产生 异常 
 的 函数 都 具有 一个 正确 的 异常 子句 ， 这个 子句 告诉 Java 哪些 异常 可能 会 被 产生 。 这个 假 
 设 十分 严格 ， 并 由 编译器 进行 检查 。 这是 一个 非常 有用 的 技术 ， 即使 这 意味着 程序员 要 
 做 更 多 的 工作 。 Java 中 的 异常 类 必须 派生 自 Throwable 类 。 
 模板 （ 通用 程序设计 ） 
 ・ 特性 描述 ： 在 不 指定 某些 数据类型 的 情况 下 编写 函数 和 类 的 技术 ， 称为 通用 程序设计 
 。 在 函数 或类 被 使用 的 时候 ， 特定 的 数据类型 会 代替 函数 或类 中 的 未指定 部分 。 所有 情 
 况 都 在 编译器 的 监管 之下 ， 不会 有 任何 问题 遗留 给 运行 期来 决定 。 模板 类 的 一个 典型 的 
 例子 就是 容器 类 。 
 ・ C++ ： 这 三种 语言 中 只有 C++ 具有 通用 类 和 函数 ， 这些 类 和 函数 用 Template 关键字 表示 
 。 C++ 标准 包含 了 一个 巨大 的 模板 类库 ， 称为 STL ， 用于 支持 一些 特殊 而 有用 的 程序设计 
 功能 。 
 ・ OP ： Object   Pascal 不 支持 模板 。 容器 类 通常 被 创建 为 TObject 类 对象 的 容器 。 
 ・ Java ： Java 同样 不 支持 模板 。 你 可以 使用 对象 容器 ， 或 采用 其它 类似 的 方法 。 
 其它 特殊 特性 
 ・ 特性 描述 ： 以下 是 其它 一些 我 谈及 的 特性 ， 它们 不是 基础 特性 ， 而且 仅为 一种 语言所 
 特有 。 
 ・ C++ ： 我 已经 提到 了 多重 继承 、 虚 基类 和 模板 。 还有 一些 另外 两种 语言所 不 具有 的 特性 
 。 C++ 支持 操作符 重载 ， 而 Java 中 支持 方法 重载 。 C++ 还 允许 程序员 重载 全局 函数 。 你 甚 
 至 可以 重载 类 运算符 ， 编写 可能 会 在 后台 被 调用 的 类型转换 方法 。 C++ 的 对象 模型 需要 拷 
 贝 构造函数 和 赋值 运算符 重载 ， 而 其它 两种 语言 则 不 需要 ， 因为 它们 基于 对象 引用 模型 
 。 
 ・ Java ： 只有 Java 在 语言 中 支持 多线程 。 对象 和 方法 支持 同步 机制 （ 使用 synchronized 
 关键字 ） ： 同一个 类 的 两个 synchronized 方法 不能 同时 运行 。 要 创建 一个 新 的 线程 只 需 
 从 Thread 类中 派生 新类 ， 并 覆盖 run ( ) 方法 。 另 一个 方法 是 实现 Runnable 接口 （ 这是 建立 
 多线程 applet 的 常用 方法 ） 。 我们 已经 讨论 过 了 碎片 回收 程序 。 Java 的 另 一个 关键 特性 
 是 代码 兼容性 ， 但是 这 并 不是 严格 的 与 语言 相关 的 。 
 ・ OP ： Object   Pascal 的 一些 特性 包括 类 引用 ， 便利 的 方法 指针 （ 这是 事件 模型 的 基础 ） 
 ， 特别 是 属性 。 属性 用来 隐藏 对 数据 成员 的 访问 ， 这些 访问 大多 是 通过 方法 进行 的 。 属 
 性 可以 直接 映射 为 对 数据 成员 的 读写操作 ， 也 可以 映射 为 访问 函数 。 即使 改变 了 访问 数 
 据 成员 的 方式 ， 也 不 需要 改变 调用 的 代码 （ 虽然 需要 重新 编译 ） ， 这 使得 属性 称为 了 一 
 个 强大 的 封装 特性 。 Java 也 将 在 1.1 版中 加入 这个 特性 ， 以 支持 Java   Beans 。 
 标准 
 ・ 特性 描述 ： 每个 语言 都 需要 有人 建立 一个 标准 ， 并 检查 是否 所有 的 实现 都 符合 这个 标 
 准 。 
 ・ C++ ： ANSI / ISO   C++ 标准 委员会 已经 完成 了 标准化 工作 。 大多数 编译器 编写者 都 努力 遵 
 守 这个 标准 ， 虽然 还有 很多 的 差异 存在 。 理论 上 的 发展 已 基本 停止 。 但 在 实现 上 ， 新 的 
 Borland   C++   Builder 虽然 并 不 很 成熟 ， 但 使 很多 人 认识 到 C++ 迫切 的 需要 一个 可视 开发 
 环境 。 同时 ， 广为 流行 的 Visual   C++ 将 C++ 向 另 一个 方向 发展 起来 ， 例如 ， 大量 使用 宏 。 
 我 的 意见 是 ， 每个 语言 都 有 它 的 开发 模型 ， 在 不 适于 某种 语言 的 环境 下 强行 使用 这种 语 
 言 是 毫无意义 的 。 
 ・ OP ： Object   Pascal 是 一个 私有 语言 ， 所以 没有 标准 。 Borland 已经 授权 给 一些 OS / 2 编 
 译器 开发商 ， 但是 没有 什么 效果 。 在 每 一个 新 版本 的 Delphi 中 ， Borland 都 扩展 了 这种 语 
 言 。 
 ・ Java ： Java 也 是 私有 语言 ， 并且 拥有 一个 同名 的 商标 。 但是 Sun 更 愿意 授权 给 其它 编译 
 器 开发商 。 Sun 自己 控制 着 这种 语言 ， 并且 好像 并 不想 为 其 建立 一个 官方 的 标准 ， 至少 目 
 前 如此 。 Sun 也 在 极力 避免 不 遵守 标准 的 虚拟机 被 开发 出来 。 
 结论 ： 语言 和 开发 环境 
 就 像 我 上面 提到 过 的 ， 虽然 我 尽力 做到 只 比较 语言 的 语法 语义 特性 ， 但 在 适当 的 环境 中 
 考察 它们 是 很 重要 的 。 这些 语言 为 不同 的 目标 开发 出来 ， 是 为了 以 不同 的 途径 解决 不同 
 的 问题 的 ， 并 在 不同 的 开发 环境 中 被 应用 。 虽然 语言 和 它们 的 开发 环境 体现 了 彼此 的 一 
 些 特性 ， 但 它们 是 为了 满足 不同 的 需要 而 建立 的 ， 就 像 我们 在 对比 这些 特性 时 看到 的 那 
 样 。 C++ 的 目标 是 强大 的 功能 和 控制能力 ， 代价 是 复杂性 提高 ； Delphi 的 目标 是 在 不 损失 
 太 多功能 的 情况 下 ， 尽可能 简单 以及 可视化 编程 和 同 Windows 紧密结合 ； Java 的 目标 是 兼 
 容性 和 分布式应用 ， 为此 不惜牺牲 一些 运行 速度 。 
 决定 这 三种 语言 命运 的 并 不是 我 这 篇文章 中 所 涉及 的 那些 语言 特性 。 Borland 的 财政状况 
 ， Microsoft 对 操作系统 的 控制 ， Sun 在 Internet 世界 的 声望 （ 许多 人 认为 的 反 微软 ） ， 
 Web 浏览器 和 Win32   API 的 前景 ， ActiveX （ 以及 Delphi 的 ActiveForms ） 将 扮演 的 角色 ， 
 这些 都 是 影响 你 选择 的 因素 （ 往往 超过 了 技术 因素 ） 。 例如 那个 非常 优秀 的 语言 Eiffel 
 ― ― Object   Pascal 和 Java 都 从中 吸取 了 很多 灵感 ， 没有 抢 到 任何 市场份额 ， 虽然 它 在 全 
 世界 的 许多 大学 中 都 十分 流行 。 
 记住 ， “ 时髦 ” 这个 词 已经 在 计算机 世界 占有 了 前所未有 的 地位 。 就 像 用户 喜欢 使用 今 
 年 新 版本 的 软件 （ 这 大概 就是 为什么 操作系统 都 以 年份 命名 ） ， 程序员 们 也 喜欢 用 最新 
 的 程序设计 语言 ， 并 希望 第一个 掌握 它 。 我们 可以 说 “ Java 并 不是 最新 的 OOP 语言 ” ， 在 
 未来 的 几年 里 ， 一些 人会 开发 出 更 时髦 的 语言 ， 而 其他人 则 会 蜂拥而上 ， 全然 忘记 了 这 
 个 世界 上 大多数 程序员 还 在 他们 的 键盘 上 敲打 着 传统 的 Cobol 语句 ！ 
 作者简介 
 Marco   Cantu 撰写 过多本 涉及 以上 谈及 的 两到 三种 语言 的 书 ， 如 Object   Pascal   and   C++ 
 ， 并 在 美国 和 其它 一些 国家 发行 。 他 为 多家 杂志 撰写 稿件 ， 并 在 他 的 公司 WinTech   Ital 
 ia 中 进行 多项 OOP 语言 和 Windows 程序设计 的 培训 。 他 喜欢 在 国际性 会议 中 发表 讲话 。 你 
 可以 在 以下 网址 找到 他 ： www . macrocantu . com 。 
 
 - - 
 
 消融 ， 消融 ， 
             融入 你 那 柔波 似的 心胸 ！ ！ ！ ！ 
                                                                         
 ※   来源 : ・ 日月 光华   bbs . fudan . edu . cn ・ [ FROM :   10.22 . 10.100 ] 
 - - 
 ※   转载 : ・ 日月 光华   bbs . fudan . edu . cn ・ [ FROM :   10.100 . 110.101 ] 
 
   
 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 [ 返回 上 一页 ]   [ 本 讨论区 ]