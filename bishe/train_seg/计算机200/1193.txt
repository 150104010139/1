日月 光华   - -   Programming 精华区 文章 阅读 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   发信人 :   freshbird   ( 真 菜鸟 ~ 快乐 的 愚人 ) ,   信 区 :   Programming 
 标     题 :   学习 Linux 网络 编程 ( 1 )   
 发信站 :   日月 光华 站   ( Mon   Apr     2   16 : 53 : 34   2001 )   ,   站 内 信件 
 
 学习 Linux 网络 编程 ( 1 ) 
 Linux 系统 的 一个 主要 特点 是 他 的 网络 功能 非常 强大 。 随着 网络 的 日益 普及 ， 基于 网络 的 
 应用 也 将 越来越 多 。   在 这个 网络时代 ， 掌握 了 Linux 的 网络 编程技术 ， 将令 每 一个 人处 
 于 不败之地 ， 学习 Linux 的 网络 编程 ， 可以 让 我们 真正 的 体会 到 网络 的 魅力 。   想 成为 一 
 位 真正 的 hacker ， 必须 掌握 网络 编程技术 。 
 现在 书店 里面 已经 有 了 许多 关于 Linux 网络 编程 方面 的 书籍 ， 网络 上 也 有 了 许多 关于 网络 
 编程 方面 的 教材 ， 大家 都 可以   去 看一看 的 。 在 这里 我会 和 大家 一 起来 领会 Linux 网络 编 
 程 的 奥妙 ， 由于 我 学习 Linux 的 网络 编程 也 开始 不久 ， 所以 我 下面 所说 的 肯定 会 有 错误 的 
 ，   还 请 大家 指点 出来 ， 在 这里 我先 谢谢 大家 了 。 
 在 这 一个 章节 里面 ， 我会 和 以前 的 几个 章节 不同 ， 在 前面 我 都 是 概括 的 说 了 一下 ，   从现 
 在 开始 我会 尽可能 的 详细 的 说明 每 一个 函数 及其 用法 。 好 了 让 我们 去 领会 Linux 的 伟大 的 
 魅力 吧 ！ 
 1 .   Linux 网络 知识 介绍 
 1.1   客户端程序 和 服务端 程序 
 网络 程序 和 普通 的 程序 有 一个 最大 的 区别 是 网络 程序 是 由 两个 部分 组成 的 - - 客户端 和服 
 务器 端 . 
 网络 程序 是 先 有 服务器程序 启动 , 等待 客户端 的 程序运行 并 建立 连接 . 一般 的 来说 是 服务 
 端的 程序   在 一个 端口 上 监听 , 直到 有 一个 客户端 的 程序 发来 了 请求 . 
 1.2   常用 的 命令 
 由于 网络 程序 是 有 两个 部分 组成 , 所以 在 调试 的 时候 比较 麻烦 , 为此 我们 有 必要 知道 一些 
 常用 的 网络 命令 
 netstat 
 命令 netstat 是 用来 显示 网络 的 连接 , 路由表 和 接口 统计 等 网络 的 信息 . netstat 有 许多 的 
 选项   我们 常用 的 选项 是   - an   用来 显示 详细 的 网络 状态 . 至于 其它 的 选项 我们 可以 使用 帮 
 助手 册 获得 详细 的 情况 . 
 telnet 
 telnet 是 一个 用来 远程 控制 的 程序 , 但是 我们 完全 可以 用 这个 程序 来 调试 我们 的 服务端 程 
 序 的 .   比如 我们 的 服务器程序 在 监听 8888 端口 , 我们 可以 用 telnet   localhost   8888 来查 
 看 服务端 的 状况 . 
 1.3   TCP / UDP 介绍 
 TCP ( Transfer   Control   Protocol ) 传输控制协议 是 一种 面向 连接 的 协议 , 当 我们 的 网络 程 
 序 使用   这个 协议 的 时候 , 网络 可以 保证 我们 的 客户端 和 服务端 的 连接 是 可靠 的 , 安全 的 . 
 
 UDP ( User   Datagram   Protocol ) 用户 数据 报 协议 是 一种 非 面向 连接 的 协议 , 这种 协议 并 不 
 能 保证 我们   的 网络 程序 的 连接 是 可靠 的 , 所以 我们 现在 编写 的 程序 一般 是 采用 TCP 协议 的 
 . 
 2 .   初等 网络函数 介绍 （ TCP ） 
 Linux 系统 是 通过 提供 套 接字 ( socket ) 来 进行 网络 编程 的 . 网络 程序 通过 socket 和 其它 几 
 个 函数 的 调用 , 会 返回 一个   通讯 的 文件 描述符 , 我们 可以 将 这个 描述符 看成 普通 的 文件 的 
 描述符 来 操作 , 这 就是 linux 的 设备 无关 性 的   好处 . 我们 可以 通过 向 描述符 读写操作 实现 
 网络 之间 的 数据 交流 . 
 2.1   socket 
 int   socket ( int   domain ,   int   type , int   protocol ) 
 domain : 说明 我们 网络 程序 所在 的 主机 采用 的 通讯 协族 ( AF _ UNIX 和 AF _ INET 等 ) .   AF _ UNIX 
 只 能够 用于 单一 的 Unix 系统 进程 间通信 , 而 AF _ INET 是 针对 Internet 的 , 因而 可以 允许 在 远 
 程   主机 之间 通信 ( 当 我们   man   socket 时 发现   domain 可选项 是   PF _ * 而 不是 AF _ * , 因为 gl 
 ibc 是 posix 的 实现   所以 用 PF 代替 了 AF , 不过 我们 都 可以 使用 的 ) . 
 type : 我们 网络 程序 所 采用 的 通讯 协议 ( SOCK _ STREAM , SOCK _ DGRAM 等 )   SOCK _ STREAM 表明 我 
 们 用 的 是 TCP 协议 , 这样 会 提供 按 顺序 的 , 可靠 , 双向 , 面向 连接 的 比特流 .   SOCK _ DGRAM   表 
 明 我们 用 的 是 UDP 协议 , 这样 只会 提供 定长 的 , 不 可靠 , 无 连接 的 通信 . 
 protocol : 由于 我们 指定 了 type , 所以 这个 地方 我们 一般 只要 用 0 来 代替 就 可以 了   socket 
 为 网络通讯 做 基本 的 准备 . 成功 时 返回 文件 描述符 , 失败 时 返回 - 1 , 看 errno 可 知道 出错 的 
 详细情况 . 
 2.2   bind 
 int   bind ( int   sockfd ,   struct   sockaddr   * my _ addr ,   int   addrlen ) 
 sockfd : 是 由 socket 调用 返回 的 文件 描述符 . 
 addrlen : 是 sockaddr 结构 的 长度 . 
 my _ addr : 是 一个 指向 sockaddr 的 指针 .   在 中 有   sockaddr 的 定义 
 struct   sockaddr { 
 unisgned   short   as _ family ; 
 char   sa _ data [ 14 ] ; 
 } ; 
 不过 由于 系统 的 兼容性 , 我们 一般 不用 这个 头文件 , 而 使用 另外 一个 结构 ( struct   sockad 
 dr _ in )   来 代替 . 在 中 有 sockaddr _ in 的 定义 
 struct   sockaddr _ in { 
 unsigned   short   sin _ family ; 
 unsigned   short   int   sin _ port ; 
 struct   in _ addr   sin _ addr ; 
 unsigned   char   sin _ zero [ 8 ] ; 
 我们 主要 使用 Internet 所以 sin _ family 一般 为 AF _ INET , sin _ addr 设置 为 INADDR _ ANY 表示 
 可以   和 任何 的 主机 通信 , sin _ port 是 我们 要 监听 的 端口号 . sin _ zero [ 8 ] 是 用来 填充 的 . 
 bind 将 本地 的 端口 同 socket 返回 的 文件 描述符 捆绑 在 一起 . 成功 是 返回 0 , 失败 的 情况 和 s 
 ocket 一样 
 2.3   listen 
 int   listen ( int   sockfd , int   backlog ) 
 sockfd : 是 bind 后 的 文件 描述符 . 
 backlog : 设置 请求 排队 的 最大 长度 . 当有 多个 客户端程序 和 服务端 相连 时 ,   使用 这个 表示 
 可以 介绍 的 排队 长度 .   listen 函数 将 bind 的 文件 描述符 变为 监听 套 接字 . 返回 的 情况 和 b 
 ind 一样 . 
 2.4   accept 
 int   accept ( int   sockfd ,   struct   sockaddr   * addr , int   * addrlen ) 
 sockfd : 是 listen 后 的 文件 描述符 . 
 addr , addrlen 是 用来 给 客户端 的 程序 填写 的 , 服务器端 只要 传递 指针 就 可以 了 .   bind , li 
 sten 和 accept 是 服务器端 用 的 函数 , accept 调用 时 , 服务器端 的 程序 会 一直 阻塞 到 有 一个 
   客户程序 发出 了 连接 .   accept 成功 时 返回 最后 的 服务器端 的 文件 描述符 , 这个 时候 服务 
 器端 可以 向 该 描述符 写 信息 了 .   失败 时 返回 - 1 
 2.5   connect 
 int   connect ( int   sockfd ,   struct   sockaddr   *   serv _ addr , int   addrlen ) 
 sockfd : socket 返回 的 文件 描述符 . 
 serv _ addr : 储存 了 服务器端 的 连接 信息 . 其中 sin _ add 是 服务端 的 地址 
 addrlen : serv _ addr 的 长度 
 connect 函数 是 客户端 用来 同 服务端 连接 的 . 成功 时 返回 0 , sockfd 是 同 服务端 通讯 的 文件 
 描述符   失败 时 返回 - 1 . 
 2.6   实例 
 服务器端 程序 
 / * * * * * * *   服务器程序   ( server . c )   * * * * * * * * * * * * / 
 # include 
 # include 
 # include 
 # include 
 # include 
 # include 
 # include 
 # include 
 int   main ( int   argc ,   char   * argv [ ] ) 
 { 
 int   sockfd , new _ fd ; 
 struct   sockaddr _ in   server _ addr ; 
 struct   sockaddr _ in   client _ addr ; 
 int   sin _ size , portnumber ; 
 char   hello [ ] = " Hello !   Are   You   Fine ? \ n " ; 
 if ( argc ! = 2 ) 
 { 
 fprintf ( stderr , " Usage : % s   portnumber \ a \ n " , argv [ 0 ] ) ; 
 exit ( 1 ) ; 
 } 
 if ( ( portnumber = atoi ( argv [ 1 ] ) ) < 0 ) 
 { 
 fprintf ( stderr , " Usage : % s   portnumber \ a \ n " , argv [ 0 ] ) ; 
 exit ( 1 ) ; 
 } 
 / *   服务器端 开始 建立 socket 描述符   * / 
 if ( ( sockfd = socket ( AF _ INET , SOCK _ STREAM , 0 ) ) = = - 1 ) 
 { 
 fprintf ( stderr , " Socket   error : % s \ n \ a " , strerror ( errno ) ) ; 
 exit ( 1 ) ; 
 } 
 / *   服务器端 填充   sockaddr 结构   * / 
 bzero ( & server _ addr , sizeof ( struct   sockaddr _ in ) ) ; 
 server _ addr . sin _ family = AF _ INET ; 
 server _ addr . sin _ addr . s _ addr = htonl ( INADDR _ ANY ) ; 
 server _ addr . sin _ port = htons ( portnumber ) ; 
 / *   捆绑 sockfd 描述符   * / 
 if ( bind ( sockfd , ( struct   sockaddr   * ) ( & server _ addr ) , sizeof ( struct   sockaddr ) ) = = - 
 1 ) 
 { 
 fprintf ( stderr , " Bind   error : % s \ n \ a " , strerror ( errno ) ) ; 
 exit ( 1 ) ; 
 } 
 / *   监听 sockfd 描述符   * / 
 if ( listen ( sockfd , 5 ) = = - 1 ) 
 { 
 fprintf ( stderr , " Listen   error : % s \ n \ a " , strerror ( errno ) ) ; 
 exit ( 1 ) ; 
 } 
 while ( 1 ) 
 { 
 / *   服务器 阻塞 , 直到 客户程序 建立 连接   * / 
 sin _ size = sizeof ( struct   sockaddr _ in ) ; 
 if ( ( new _ fd = accept ( sockfd , ( struct   sockaddr   * ) ( & client _ addr ) , & sin _ size ) ) = = - 1 ) 
 { 
 fprintf ( stderr , " Accept   error : % s \ n \ a " , strerror ( errno ) ) ; 
 exit ( 1 ) ; 
 } 
 fprintf ( stderr , " Server   get   connection   from   % s \ n " , 
 inet _ ntoa ( client _ addr . sin _ addr ) ) ; 
 if ( write ( new _ fd , hello , strlen ( hello ) ) = = - 1 ) 
 { 
 fprintf ( stderr , " Write   Error : % s \ n " , strerror ( errno ) ) ; 
 exit ( 1 ) ; 
 } 
 / *   这个 通讯 已经 结束   * / 
 close ( new _ fd ) ; 
 / *   循环 下 一个   * / 
 } 
 close ( sockfd ) ; 
 exit ( 0 ) ; 
 } 
 客户端程序 
 / * * * * * * *   客户端程序   client . c   * * * * * * * * * * * * / 
 # include 
 # include 
 # include 
 # include 
 # include 
 # include 
 # include 
 # include 
 int   main ( int   argc ,   char   * argv [ ] ) 
 { 
 int   sockfd ; 
 char   buffer [ 1024 ] ; 
 struct   sockaddr _ in   server _ addr ; 
 struct   hostent   * host ; 
 int   portnumber , nbytes ; 
 if ( argc ! = 3 ) 
 { 
 fprintf ( stderr , " Usage : % s   hostname   portnumber \ a \ n " , argv [ 0 ] ) ; 
 exit ( 1 ) ; 
 } 
 if ( ( host = gethostbyname ( argv [ 1 ] ) ) = = NULL ) 
 { 
 fprintf ( stderr , " Gethostname   error \ n " ) ; 
 exit ( 1 ) ; 
 } 
 if ( ( portnumber = atoi ( argv [ 2 ] ) ) < 0 ) 
 { 
 fprintf ( stderr , " Usage : % s   hostname   portnumber \ a \ n " , argv [ 0 ] ) ; 
 exit ( 1 ) ; 
 } 
 / *   客户程序 开始 建立   sockfd 描述符   * / 
 if ( ( sockfd = socket ( AF _ INET , SOCK _ STREAM , 0 ) ) = = - 1 ) 
 { 
 fprintf ( stderr , " Socket   Error : % s \ a \ n " , strerror ( errno ) ) ; 
 exit ( 1 ) ; 
 } 
 / *   客户程序 填充 服务端 的 资料   * / 
 bzero ( & server _ addr , sizeof ( server _ addr ) ) ; 
 server _ addr . sin _ family = AF _ INET ; 
 server _ addr . sin _ port = htons ( portnumber ) ; 
 server _ addr . sin _ addr = * ( ( struct   in _ addr   * ) host - > h _ addr ) ; 
 / *   客户程序 发起 连接 请求   * / 
 if ( connect ( sockfd , ( struct   sockaddr   * ) ( & server _ addr ) , sizeof ( struct   sockaddr ) ) 
 = = - 1 ) 
 { 
 fprintf ( stderr , " Connect   Error : % s \ a \ n " , strerror ( errno ) ) ; 
 exit ( 1 ) ; 
 } 
 / *   连接 成功 了   * / 
 if ( ( nbytes = read ( sockfd , buffer , 1024 ) ) = = - 1 ) 
 { 
 fprintf ( stderr , " Read   Error : % s \ n " , strerror ( errno ) ) ; 
 exit ( 1 ) ; 
 } 
 buffer [ nbytes ] = \ ; 
 printf ( " I   have   received : % s \ n " , buffer ) ; 
 / *   结束 通讯   * / 
 close ( sockfd ) ; 
 exit ( 0 ) ; 
 } 
 MakeFile 
 这里 我们 使用 GNU   的 make 实用程序 来 编译 .   关于 make 的 详细 说明 见   Make   使用 介绍 
 #########   Makefile   ########### 
 all : server   client 
 server : server . c 
 gcc   $ ^   - o   $ @ 
 client : client . c 
 gcc   $ ^   - o   $ @ 
 运行 make 后会 产生 两个 程序 server ( 服务器端 ) 和 client ( 客户端 )   先 运行 . / server   port 
 number &   ( portnumber 随便 取 一个 大于 1204 且 不 在 / etc / services 中 出现 的 号码   就 用 888 
 8 好 了 ) , 然后 运行   . / client   localhost   8888   看看 有 什么 结果 .   ( 你 也 可以 用 telnet 和 n 
 etstat 试一试 . )   上面 是 一个 最 简单 的 网络 程序 , 不过 是不是 也 有点烦 . 上面 有 许多 函数 我 
 们 还 没有 解释 .   我会 在 下 一章 进行 的 详细 的 说明 . 
 2.7   总结 
 总的来说 网络 程序 是 由 两个 部分 组成 的 - - 客户端 和 服务器端 . 它们 的 建立 步骤 一般 是 : 
 服务器端 
 socket - - > bind - - > listen - - > accept 
 客户端 
 socket - - > connect   
 
 - - 
 ※   来源 : ・ 日月 光华 站   bbs . fudan . edu . cn ・ [ FROM :   202.119 . 32.102 ] 
 
   
 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 [ 返回 上 一页 ]   [ 本 讨论区 ]