日月 光华   - -   SE 精华区 文章 阅读 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   发信人 :   jiachong   ( 甲虫 ) ,   信 区 :   SE 
 标     题 :   [ 转载 ] 软件 编程 规范 培训 实例 与 练习 
 发信站 :   日月 光华   ( 2003 年 04 月 20 日 22 : 40 : 14   星期天 ) ,   站 内 信件 
 
 【   以下 文字 转载自   FDU _ C . S .   讨论区   】 
 【   原文 由   fdchosen   所 发表   】 
 
 软件 编程 规范 培训 实例 与 练习 
 
 &# 376 ; 	 问题 分类 
 1             逻辑 类 问题 （ A 类 ） － 指 设计 、 编码 中 出现 的 计算 正确性 和 一致性 、 程序逻辑 控制 
 
 等 方面 出现 的 问题 ， 在 系统 中起 关键作用 ， 将 导致 软件 死机 、 功能 正常 实现 等 严重 问题 ； 
 
 
             接口类 问题 （ B 类 ） － 指 设计 、 编码 中 出现 的 函数 和 环境 、 其他 函数 、 全局 / 局部 变 
 
 量 或 数据 变量 之间 的 数据 / 控制传输 不 匹配 的 问题 ， 在 系统 中起 重要 作用 ， 将 导致 模块 间配 
 
 合 失效 等 严重 问题 ； 
             维护 类 问题 （ C 类 ） － 指 设计 、 编码 中 出现 的 对 软件系统 的 维护 方便 程度 造成 影响 的 
 
 问题 ， 在 系统 中不起 关键作用 ， 但 对系统 后期 维护 造成 不便 或 导致 维护费用 上升 ； 
             可 测试 性 问题 （ D 类 ） － 指 设计 、 编码 中因 考虑不周 而 导致 后期 系统 可 测试 性差 的 问 
 
 题 。 
 
 &# 376 ; 	 处罚 办法 
 	             问题 发生率 ： 
 	                                   P = D / S 
 	                                   D = DA + 0.5 DB + 0.25 DC 
 	 
 	             其中 ： 
 	                             P       － 问题 发生率 
 	                             D       － 1 个 季度 内 错误 总数 
 	                             DA   － 1 个 季度 内 A 类 错误 总数 
 	                             DB   － 1 个 季度 内 B 类 错误 总数 
 	                             DC   － 1 个 季度 内 C 类 错误 总数 
 	                             S       － 1 个 季度 内 收到 问题 报告单 总数 
             1 ） 当 D ≥ 3 时 ， 如果 P ≥ 3 ％ ， 将 进行 警告 处理 ， 并 予以 公告 ； 
             2 ） 当 D ≥ 5 时 ， 如果 P ≥ 5 ％ ， 将 进行 罚款 处理 ， 并 予以 公告 。 
   
 目       录 
 一 、 逻辑 类 代码 问题 	 第 5 页 
 1 、 变量 / 指针 在 使用 前 就 必须 初始化 	 第 5 页 
 【 案例 1.1 . 1 】 	 第 5 页 
 2 、 防止 指针 / 数组 操作 越界 	 第 5 页 
 【 案例 1.2 . 1 】 	 第 5 页 
 【 案例 1.2 . 2 】 	 第 6 页 
 【 案例 1.2 . 3 】 	 第 7 页 
 【 案例 1.2 . 4 】 	 第 8 页 
 3 、 避免 指针 的 非法 引用 	 第 9 页 
 【 案例 1.3 . 1 】 	 第 9 页 
 4 、 变量 类型定义 错误 	 第 10 页 
 【 案例 1.4 . 1 】 	 第 10 页 
 5 、 正确 使用 逻辑 与 && 、 屏蔽 & 操作符 	 第 17 页 
 【 案例 1.5 . 1 】 	 第 17 页 
 6 、 注意 数据类型 的 匹配 	 第 18 页 
 【 案例 1.6 . 1 】 	 第 18 页 
 【 案例 1.6 . 2 】 	 第 18 页 
 7 、 用于 控制 条件 转移 的 表达式 及 取值 范围 是否 书写 正确 	 第 20 页 
 【 案例 1.7 . 1 】 	 第 20 页 
 【 案例 1.7 . 2 】 	 第 21 页 
 【 案例 1.7 . 3 】 	 第 22 页 
 8 、 条件 分支 处理 是否 有 遗漏 	 第 24 页 
 【 案例 1.8 . 1 】 	 第 24 页 
 9 、 引用 已 释放 的 资源 	 第 26 页 
 【 案例 1.9 . 1 】 	 第 26 页 
 10 、 分配资源 是否 已 正确 释放 	 第 28 页 
 【 案例 1.10 . 1 】 	 第 28 页 
 【 案例 1.10 . 2 】 	 第 29 页 
 【 案例 1.10 . 3 】 	 第 30 页 
 【 案例 1.10 . 4 】 	 第 32 页 
 【 案例 1.10 . 5 】 	 第 33 页 
 【 案例 1.10 . 6 】 	 第 35 页 
 【 案例 1.10 . 7 】 	 第 38 页 
 11 、 防止 资源 的 重复 释放 	 第 39 页 
 【 案例 1.11 . 1 】 	 第 39 页 
 12 、 公共资源 的 互斥性 和 竞用 性 	 第 40 页 
 【 案例 1.12 . 1 】 	 第 40 页 
 【 案例 1.12 . 2 】 	 第 40 页 
 二 、 接口类 代码 问题 	 第 43 页 
 1 、 对 函数参数 进行 有效性 检查 	 第 43 页 
 【 案例 2.1 . 1 】 	 第 43 页 
 【 案例 2.1 . 2 】 	 第 43 页 
 【 案例 2.1 . 3 】 	 第 44 页 
 【 案例 2.1 . 4 】 	 第 46 页 
 【 案例 2.1 . 5 】 	 第 47 页 
 【 案例 2.1 . 6 】 	 第 48 页 
 2 、 注意 多 出口 函数 的 处理 	 第 49 页 
 【 案例 2.2 . 1 】 	 第 49 页 
 三 、 维护 类 代码 问题 	 第 51 页 
 1 、   统一 枚举 类型 的 使用 	 第 51 页 
 【 案例 3.1 . 1 】 	 第 51 页 
 2 、   注释 量 至少 占 代码 总量 的 20 ％ 	 第 51 页 
 【 案例 3.2 . 1 】 对 XXX 产品 BAM 某 版本 部分 代码 注释 量 的 统计 	 第 51 页 
 四 、 产品 兼容性问题 	 第 52 页 
 1 、 系统配置 、 命令 方式 	 第 52 页 
 【 案例 4.1 . 1 】 	 第 52 页 
 【 案例 4.1 . 2 】 	 第 53 页 
 2 、 设备 对接 	 第 54 页 
 【 案例 4.2 . 1 】 	 第 54 页 
 3 、 其他 	 第 55 页 
 【 案例 4.3 . 1 】 	 第 55 页 
 五 、 版本控制 问题 	 第 58 页 
 1 、 新老 代码 中 同一 全局变量 不 一致 	 第 58 页 
 【 案例 5.1 . 1 】 	 第 58 页 
 六 、 可 测试 性 代码 问题 	 第 59 页 
 1 、 调试信息 / 打印信息 的 正确性 	 第 59 页 
 【 案例 6.1 . 1 】 	 第 59 页 
 
 
 
 
   
 一 、 逻辑 类 代码 问题 
 1 、 变量 / 指针 在 使用 前 就 必须 初始化 
 【 案例 1.1 . 1 】 
 	 C语言 中 最大 的 特色 就是 指针 。 指针 的 使用 具有 很强 的 技巧性 和 灵活性 ， 但 同时 也 带来 了 
 
 很大 的 危险性 。 在 XXX 的 代码 中有 如下 一端 对 指针 的 灵活 使用 ： 
 ...   ... 
 
         _ UC   * puc _ card _ config _ tab ;   
 
 ...   ... 
                 Get _ Config _ Table (   AMP _ CPM _ CARD _ CONFIG _ TABLE ,   
                                                     & ul _ card _ config _ num ,   
                                                     & puc _ card _ config _ tab ,   
                                                     use _ which _ data _ area 
                                                 ) ; 
 ...   ... 
             b _ middle _ data _ ok   =   generate _ trans _ middle _ data _ from _ original _ data ( 
                                                                 puc _ card _ config _ tab , 
                                                                 Ul _ card _ config _ num ) 
 ....   ... 
 其中 红色 部分 巧妙 的 利用 指向 指针 的 指针 为 指针 puc _ card _ config _ tab 赋值 , 而 在 兰色 部分 
 
 使用 该 指针 。 但 在 Get _ Config _ Table 函数 中有 可能 失败 返回 而 不 给 该 指针 赋值 。 因此 ， 以 
 
 后 使用 的 可能 是 一个 非法 指针 。 
 指针 的 使用 是 非常灵活 的 ， 同时 也 存在 危险性 ， 必须 小心 使用 。 指针 使用 的 危险性 举世 共 
 
 知 。 在 新 的 编程 思想 中 ， 指针 基本上 被 禁止 使用 （ JAVA 中 就是 这样 ） ， 至少 也 是 被 限制 使 
 
 用 。 而 在 我们 交换机 的 程序 中 大量 使用 指针 ， 并且 有增无减 。 
 
 2 、 防止 指针 / 数组 操作 越界 
 【 案例 1.2 . 1 】 
                 在 香港 项目 测试 中 ， 发现 ISDN 话机 拨新 业务 号码 时 ， 若 一位 一位 的 拨 至 18 位 ， 不 
 
 会 有 问题 。 但 若 先 拨 完 号码 再 成组 发送 ， 会 导致 MPU 死机 。 
                   
 处理过程 ： 
                 查错 过程 很 简单 ， 按 呼叫 处理 的 过程 检查 代码 ， 发现 某 一处 的 判断 有误 ， 本 应为 
 
 小于 18 的 判断 ， 写成 了 小于 等于 18 。                         
 
 结     论 ： 
                   代码 编写 有误 。 
 
 思考 与 启示 ： 
 	 1 、 极限 测试 必须 注意 ， 测试 前 应对 某项 设计 的 极限 做好 充分 测试 规划 。 
                     2 、 测试 极限 时 还要 注意 多种 业务 接入点 ， 本例 为 ISDN 。 对于 交换机 来说 ， 任何 
 
 一种 业务 都 要 分别 在 模拟 话机 、 ISDN 话机 、 V5 话机 、 多种形式 的 话务台 上 做 测试 。 对于 中 
 
 继 的 业务 ， 则 要 充分考虑 各种 信令 ： TUP 、 ISUP 、 PRA 、 NO1 、 V5 等等 。 
 
 【 案例 1.2 . 2 】 
 	 对 某 交换 类 进行 计费 测试 ， 字冠 011 对应 1 号 路由 、 1 号子 路由 ， 有 4 个 中继 群 11 , 12 , 13 , 14 
 
 ( 都 属于 1 # 模块 ) ， 前后 两个 群 分别 构成 自环 。 其中 11 , 13 群向 为 出 中继 , 12 , 14 群向 为 入 中继 
 
 ， 对 这 四个 群 分别 进行 计费 设置 ， 对 出入 中继 都 计费 。 电话 60640001 拨打 01160010001 两次 
 
 ， 使 四个 群 都 有 机会 被 计费 ， 取 话单 后 浏览 话单 发现 对 11 群 计费 计次 表 话单 出 中继 群号 不 
 
 正确 ， 其它 群 的 计次 表中出 中继 群号 正常 。 
 
 处理过程 ： 
 	 与 开发人员 在 测试 组 环境 多次重复 以上 步骤 ， 发现 11 群 的 计次 表 话单 有时 正常 ， 有时 其出 
 
 中继 群号 就 为 一个 随机 值 ， 发生 异常 的 频率 比较 高 。 为什么 其它 群 的话 单 正常 ， 唯独 11 群 
 
 不 正常 呢 ？ 11 群是 四个 群中 最小 的 群 ， 其中 继 计次 表 位于 缓冲区 的 首位 ， 打 完 电话 后 查询 
 
 内存 发现 出 中继 群号 在 内存 中是 正确 的 ， 取完 话单 后 再查 就 不 正确 了 。 
 
 结     论 ： 
 	 话单 池 的 一个 备份 指针 Pool _ head _ 1 和 中继 计次 表 的 头 指针 重合 ， 影响 到 第一个 中继 计次 
 
 表 的 计费 。 
 
 思考 与 启示 ： 
 	 随机 值 的 背后 往往 隐藏 着 指针 问题 ， 两块 内存 缓冲区 的 交界处 比较 容易 出现 问题 ， 在 编程 
 
 时 是 应该 注意 的 地方 。 
 
 【 案例 1.2 . 3 】 
 【 正                         文 】 
                     在 接入网 产品 A 测试 中 ， 在 内存 数据库 正常 的 情况 下 的 各种 数据库 方面 的 操作 都 
 
 是 正常 的 。 为了 进行 数据库 异常 测试 ， 于是 将 数据库 内容 人为 地 破坏 了 。 发现 在 对 数据库 
 
 进行 比较 操作 时 ， 出现 程序 跑 死 了 现象 。 
 	 经过 跟踪 调试 发现 问题 出现 在 如下 一段 代码 中 :         
 1 	 for ( i = 0 ;   i < pSysHead - > dbf _ count ;   i ++ ) 
 2 	 { 
 3 	                         pDBFat   =   ( _ NM _ DBFAT _ STRUC   * ) ( NVDB _ BASE   +   DBFAT _ OFFSET   +   i * DBFAT _ 
 
 LEN ) ; 
 4 	 	 if ( fat _ check ( pDBFat )   ! =   0 )   
 5 	 	 { 
 6                               	 	 pSysHead - > system _ flag   =   0 ; 
 7                                 	 	 head _ sum ( ) ; 
 8                               	 	 continue ; 
 9                         	 } 
 10                         	 if ( strlen ( dbf - > dbf _ name )   ! =   0   &&   strncmp ( dbf - > dbf _ name ,   pDBFat - 
 
 > dbf _ name ,   strlen ( dbf - > dbf _ name ) )   = =   0 ) 
 11                         	 { 
 12                               	 	 dbf _ ptr1   =   ( _ UC   * ) pDBFat - > dbf _ head ; 
 13                               	 	 filesize   =   pDBFat - > dbf _ fsize ; 
 14                                 	 	 break ; 
 15                       	 } 
 16       	 } 
                 在 测试 时 发现 程序 死 在 循环 之中 ， 得到 的 错误 记录 是 " Bus   Error " （ 总线 出错 ） ， 
 
 由此 可以 说明 出现 了 内存 操作 异常 。 
 	 经过 跟踪 变量值 发现 循环 变量 i 的 阀值 pSysHead - > dbf _ count 的 数值 为 0xFFFFFFFF ， 该值 是 
 
 从 被 破坏 的 内存 数据库 中 获取 的 ， 正常 情况 下 该值 小于 127 。 而 pDBFat 是 数据库 的 起始 地址 
 
 ， 如果 pSysHead - > dbf _ count 值 异常 过大 ， 将 导致 pDBFat 值 超过 最大 内存地址 值 ， 随后 进行 
 
 的 内存 操作 将 导致 内存 操作 越界 错误 ， 因而 在 测试 过程 中 数据库 破坏 后 就 出现 了 主机 死机 
 
 的 现象 。 
 	 上面 的 问题 解决 起来 很 容易 ， 只 需 在 第一行 代码 中 增加 一个 判断 条件 即可 ， 如下 ： 
 　 for ( i = 0 ;   i < pSysHead - > dbf _ coun   &&   i   <   MAX _ DB _ NUM ;   i ++ ) 
               / /   MAX _ DB _ NUM = 127 
 
 	 这样 就 保证 了 循环 变量 i 的 值 在 正常 范围 内 ， 从而 避免 了 对 指针 pDBFat 进行 内存 越界 的 操 
 
 作 。 
 
 　 　 从 上面 的 测试 过程 中 ， 我们 可以 看到 ： 如此 严重 的 问题 ， 仅仅 是 一个 简单 的 错误 引起 
 
 的 。 实际上 ， 系统 的 不 稳定 往往 是 由 这些 看似 很 简单 的 小 错误 导致 的 。 这个 问题 给 我们 教 
 
 训 的 是 ： 在 直接 对 内存地址 进行 操作 时 ， 一定 要 保证 其值 的 合法性 ， 否则 容易 引起 内存 操 
 
 作 越界 ， 给 系统 的 稳定性 带来 潜在 的 威胁 。 	 
 
 【 案例 1.2 . 4 】 
 	 近日 在 CDB 并行 测试 中 发现 一个 问题 ： 我们 需要 的 小区 负荷 话统 结果 总是 为 零 ， 开始 还 以 
 
 为 小区 负荷 太小 ， 于是 加大 短消息 下发 数量 ， 但 还 为 零 ， 于是 在 程序 中 加入 测试代码 ， 把 
 
 收到 的 数据 在 BAM 上 打印 出来 , 
 	 结果 打印 出来 的 数据 正常 , 不 可能 为 零 , 仔细 查看 相关 代码 , 问题 只 可能 在 指针 移位 上 有 问 
 
 题 , 果然 在 函数 中 发现 一处 比较 隐蔽 的 错误 。 
 
 / *   功能 : 一个 BM 模块 内 所有 小区 CDB 侧 广播 消息 忙 闲 情况           * / 
 / * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / 
 void   Cell _ CBCH _ Load _ Static ( struct   MsgCB   FAR   * pMsg ) 
             { 
 	 。 。 。 
 	 
 	 memcpy ( ( _ UC   * ) & tmp _ msg , pMsg , sizeof ( tmp _ msg ) ) ; 
 	 pMsg = pMsg + sizeof ( tmp _ msg ) ; / / sizeof ( tmp _ msg ) = 10 ; 本意 是 想 移动 10 个 字节 , 可是 实际上 
 
 指针 移动 了 10 * sizeof ( struct   MsgCB ) 个 字节 ; 
 	 CellNum = tmp _ msg . usCellNum ; 
 	 。 。 。 
             } 
 1 
             所以 结构 指针 传入 函数 后 ， 如 要 进行 指针 移动 操作 ， 最好 先 将 其 转化 为 _ UC 型 再说 。 
 
 总之 指针 操作 要 小心 为 上 。 
 
 
 3 、 避免 指针 的 非法 引用 
 【 案例 1.3 . 1 】 
 【 正                         文 】 
 在 一次 测试 中 ， 并 没有 记得 做 了 什么 操作 ， 发现 HONET 系统 的 主机 复位 了 ， 之后 ， 系统 又工 
 
 作 正常 了 。 由于 没有 打开 后台 的 跟踪 窗口 ， 当时 查 了 半天 没有 眉目 。 过 了 半天 ， 现象 又 出 
 
 现了 ， 而且 这次 是 主机 在 反复 复位 ， 系统 根本无法 正常 工作 了 。 
 我 凭 记忆 ， 判断 应该 是 与 当时 正在 测试 的 DSL 板 的 端口配置 有关 。 于是 将板 上 所有 端口配置 
 
 为 普通 2B + D 端口 ， 重新 加载 在 主机 数据 ， 现象 消失 。 于是 初步 定位 为 主机 在 DSL 端口 处理 过 
 
 程中 有 重大 错误 。 
 我 在 新 的 数据 上 努力 恢复原 出 问题 的 现象 ， 却 一直 没有 重现 ， 于是 恢复原 数据 ， 加载 后立 
 
 即 重现 。 并 注意 到 ， 当 DSL 端口 激活 时 ， 主机 复位 。 仔细 比较 两种 数据 的 差别 ， 发现 出现 主 
 
 机 复位 问题 的 数据 中 DSL 板 配置 了 MNT / MLT 端口 ， 但是 没有 做 DSL 端口 之间 的 半 永久 数据 。 
 
 
 于是 在 程序 中 不断 加 打印 语句 ， 通过 后台 的 DBWIN 调试程序 跟踪 ， 最后 终于 定位 为 ： 每当 执 
 
 行到 portdsl . c 的 DeviceDslMsgProc ( ) 函数 中 处理 U 口透传 的 
 if   (   SPC _ STATE _ OK   = =   pSpcCB - > bySpcState   ) 
 语句 时 ， 主机 复位 。 但是 该 语句 似乎 并 无 不妥 。 
 再 分析 整个 函数 ， pSpcCB 在 函数 前 部分 已经 被 赋值 ， 
 pSpcCB   =   SpcCB   +   ( PortTable + index ) - > spcNo ; 
 但 由于 得到   index   后 ， 没有 任何 判断 ， 导致 若 MNT / MLT 端口 没有 做半 永久 ， 端口 激活 后 ， 
 
 执行 此 部分 函数 ， ( PortTable + index ) - > spcNo   有 可能 为 NULL _ WORD ， 于是 ， 运算 后 ， pSpc 
 
 CB   可能 为 非法 值 。 此时 主机 在 取 进行 判断 ， 就 不知 会 导致 什么 后果 了 。 
 其实 ， 改 起来 很 简单 ， 只要 在 这 两句 前 增加 一个 判断 就行了 。 于是 ， 修改 代码 为 ： 
 if   (   ( PortTable + index ) - > spcNo   ! =   NULL _ WORD ) 
 { 
 	 pSpcCB   =   SpcCB   +   ( PortTable + index ) - > spcNo ; 
 	 if   (   SPC _ STATE _ OK   = =   pSpcCB - > bySpcState   ) 
 	 { 。 。 。 } 
 } 
 	 修改 后 ， 问题 不再 重现 。 
 经过 分析 可以 发现 ， 编译 环境 是 有 很大 的 容许 空间 的 ， 若 主机 没有 做 充分 的 保护 ， 很 可能 
 
 会 有 极 严重 的 随即 故障 出现 。 所以 编程 时 一定 要 考虑 各种 可能 情况 ； 而 测试 中 遇到 此类 死 
 
 机 问题 ， 则 要 耐心 的 定位 到 具体 是 执行 哪句 代码 时 出现 的 ， 再 进行 分析 。 因为 问题 很 隐蔽 
 
 ， 直接 分析 海 一样 的 代码 是 很 难 发现 的 。 
 
 
 4 、 变量 类型定义 错误 
 【 案例 1.4 . 1 】 
 【 正                         文 】 
                 在 FRI 板上 建 几条 FRPVC ， 其 DLCI 类型 分别 为 ： 10Bit / 2bytes 、 10bit / 3bytes 、 16 
 
 bit / 3bytes 、 17bit / 4bytes 、 23bit / 4bytes 。 相应 的 DLCI 值为 ： 16 、 234 、 991 、 126975 、 
 
 1234567 ， 然后 保存 ， 重起 MUX ， 观察 PVC 的 恢复 情况 ， 结果 DLCI 值为 16 、 234 和 991 的 PVC 正 
 
 确 恢复 ， 而 DLCI = 126975 的 PVC 恢复 的 数据 错误 为 61439 ， 而 DLCI = 1234567 的 PVC 完全 没有 恢 
 
 复 。 
                 对于 17 / 4 类型 ， DLCI = 126975 的 PVC 在 恢复 时 变成 61439 ， 根据 这 条 线索 ， 查找 原因 
 
 ， 发现 126975 - 61439 = 65535 ， 转化 二进制 就是 10000000000000000 ， 也就是说 在 数据恢复 或 
 
 保存 时 把 原 数据 的 第一个 1 给 忽略 了 。 此时 第一个 想法 是 ： 在 程序处理 中 ， 把 无 符号长 整型 
 
 变量 当作 短 整型 变量 处理 了 ， 为了 证实 这个 判断 ， 针对 17bit / 4bytes 类型 又 重新 设计 测试 
 
 用例 ： （ 1 ）   先建 PVC ， DLCI = 65535 ， 然后 保存 ， 重起 MUX ， 观察 PVC 的 恢复 情况 ， 发现 PVC 
 
 能够 正确 恢复 ； 
 （ 2 ） 再建 PVC ， DLCI = 65536 ， 然后 保存 ， 重起 MUX ， 观察 PVC 的 恢复 情况 ， 此时 PVC 不能 正确 
 
 恢复 。 
 至此 基本 可以 断定 原因 就是 出 在 这里 。 带 着 这个 目的 查看 原代码 ， 发现 在 以下 代码 中有 问 
 
 题 ： 
 int 	 _ GetFrDlci (   DWORD *   dwDlci ,   char *   str ,   DWORD   dwDlciType ,   DWORD   dwPortType ,   
 
 DWORD   dwSlotID ,   DWORD   dwPortID ) 
 {                     DWORD     tempDlci ; 
 	 char 	 szArg [ 80 ] ; 
 1 	 char 	 szLine [ 80 ] ; 
 	 ID 	 LowPVCEP ; 
                         DWORD 	 dwDlciVal [ 5 ] [ 2 ]   = 
       	 	 {   { 16 , 1007 } ,   { 16 , 1007 } ,   { 1024 , 64511 } , 
       	 	     { 2048 , 129023 } ,   { 131072 , 4194303 }   }   ; 
                         ． ． ． 
 } 
 
 typedef   struct   tagFrPppIntIWF 
 { 
 	 ． ． ． 
 	 WORD 	 wHdlcPort ; 
 	 WORD 	 wHdlcDlci ;             
 	 WORD 	 wPeerHdlcDlci ;       
 	 WORD 	 wPeerOldAtmPort ; 
 	 ． ． ． 	 
 } 	 SFrPppIntIWFData ; 
 
 DWORD   	 SaveFrNetIntIWFData   (   DWORD   * pdwWritePoint   ) 
 { 
 	 BYTE 	 bSlotID ,   bPeerSlotID ; 
 	 DWORD 	 dwCCID ,   dwPeerCCID ; 
 	 WORD 	 wHdlcPort ,   wAtmPort ,   wIci ,   wPeerIci ,   wPeerHdlcPort   ; 
 	 WORD 	 wCount ; 
                         ． ． ． 
 } 
 
 DWORD   	 SaveFrNetExtIWFData   (   DWORD   * pdwWritePoint   ) 
 { 
 	 BYTE 	 bSlotID ; 
 	 DWORD 	 dwCCID ,   dwPeerCCID ; 
 	 WORD 	 wHdlcPort ,   wAtmPort ,   wIci   ; 
 	 WORD 	 wCount ; 
 	 ． ． ． 
 unSevData . FrNetExtIWF [ wCount ] . bSlotID 	 =   bSlotID ; 
 	 unSevData . FrNetExtIWF [ wCount ] . wHdlcPort 	 =   wHdlcPort ; 
 	 unSevData . FrNetExtIWF [ wCount ] . wHdlcDlci 	 =   gFrPVCEP [ bSlotID   ] [   gFrPVCC [ bSlotID 
 
 ] [ dwCCID ] . dwLoPVCEP   ] . dwDLCI ; 
 	 unSevData . FrNetExtIWF [ wCount ] . wOldAtmPort 	 =   wAtmPort ; 
 	 unSevData . FrNetExtIWF [ wCount ] . wAtmDlci 	 =   gFrPVCEP [   bSlotID   ] [   gFrPVCC [ bSlotID 
 
 ] [ dwCCID ] . dwHiPVCEP   ] . dwDLCI ; 
 	 unSevData . FrNetExtIWF [ wCount ] . dwMapMode   =   gFrPVCC [ bSlotID ] [ dwCCID ] . dwMapMode ; 
 
 
 　 　 　 　 　 ． ． ． 
               } 
 
 
 DWORD   RestoreFrNetExtIWFData   (   WORD   wSlotID ,   BYTE   * pReadPoint   ) 
 { 
 	 WORD 	 wCount ,   wTotalNetIWF ; 
 	 BYTE 	 bSlotID ,   bHdlcDlciType ,   bAtmDlciType ; 
 	 WORD 	 wOldAtmPort ,   wAtmDlci ,   wHdlcPort ,   wHdlcDlci ;     
 	 DWORD 	 dwMapMode ,   dwCIR ,   dwBe ; 
 	 DWORD 	 dwCCID ,   dwResult ,   dwAtmPort ; 
 	 wTotalNetIWF   =   g _ MuxData . SevDataSize . wFrNetExtIWFNum ; 
 	 ． ． ． 
 } 
 
 DWORD   RestoreFrHdlcIntIWFData   (   WORD   wSlotID ,   BYTE   * pReadPoint   ) 
 { 
 	 WORD 	 wCount ,   wTotalHdlcIWF ; 
 	 DWORD 	 dwCCID ,   dwPeerCCID ,   dwAtmPort ,   dwPeerAtmPort ; 
 	 DWORD 	 dwResult ; 
 	 BYTE 	 bSlotID ,   bPeerSlotID ; 
 	 WORD 	 wHdlcPort ,   wOldAtmPort ,   wCIR ; 
 	 WORD 	 wPeerHdlcPort ,   wPeerOldAtmPort ; 
                         ． ． ． 
 } 
 
                 其中 涉及 DLCI 值 的 变量 都 为 WORD （ 即 无 符号 短 整型 ） 类型 ， 在 程序 的 处理 时 ， 出 
 
 现 WORD 和 DWORD （ 无 符号长 整型 ） 类型 在 一句 中 同时 存在 的 情况 ， 至此 可以 判断 问题 出 在 这 
 
 里 。 由于 DLCI 值 在 不同 类型 时 的 取值 范围 不同 ， 前 三种 类型 的 取值 范围 为 16 ~ 991 ， 第四种 
 
 取值 范围 为 2048 ~ 126975 ， 第五种 取值 范围 为 131072 ~ 4194303 ， 所以 当 采用 前 三种 DLCI 类型 
 
 时 ， 采用 WORD 类型 最大值 为 65535 ， 已经 完全 够用 了 ； 而 对于 第四种 类型 时 ， 其 取值 在 超过 
 
 65535 时 ， 获取 DLCI 值 的 函数 _ GetFrDlci （ ） 采用 DWORD 类型 ， 而 负责 保存 和 恢复 的 两个 函 
 
 数 SaveFrNetExtIWFData （ ） 和 RestoreFrNetExtIWFData （ ） ， 都 把 DLCI 的 值 当作 WORD 类型 
 
 进行 处理 ， 因此 导致 DLCI 取值 越界 ， 于是 程序 把 原本 为长 整型 的 DLCI 强制 转换成 整型 ， 从 
 
 而 导致 DLCI 值 在 恢复 时 ， 比原 数据 小 65536 。 而 在 程序运行 过程 中 ， 这些 数据 保存 在 DRAM 中 
 
 ， 程序运行 直接 从 DRAM 中 获取数据 ， 程序 不会 出错 ； 当 FRI 板 复位 或 插拔 后 ， 需要 从 FLASH 
 
 中 读取数据 ， 此时 恢复 函数 的 错误 就 表现 出来 。 
               另 一个 问题 是 为什么 23 / 4 类型 的 DLCI 数据 不能 恢复 ？ 这是 由于 对于 23 / 4 类型 的 PVC 
 
 ， 其 DLCI 的 取值 范围 为 ： 131072 ~ 4194303 ， 而 程序 强制 转换 并 恢复 的 数据 最大 只能 是 6553 
 
 5 ， 所以 这条 PVC 不能 恢复 。 
                 至此 ， DLCI 数据恢复 出错 的 原因 完全 找到 ， 解决 的 方法 是 将 DLCI 的 类型 改为 DWOR 
 
 D 类型 。 从 这个 案例 可以 看出 ， 在 程序开发 中 一个 很 低级 的 错误 ， 将 在 实际 工作 中 造成 很严 
 
 重 的 后果 。 
 
 【 案例 1.4 . 2 】 
 【 正                         文 】 
                 在 FRI 板上 建 几条 FRPVC ， 其 DLCI 类型 分别 为 ： 10Bit / 2bytes 、 10bit / 3bytes 、 16 
 
 bit / 3bytes 、 17bit / 4bytes 、 23bit / 4bytes 。 相应 的 DLCI 值为 ： 16 、 234 、 991 、 126975 、 
 
 1234567 ， 然后 保存 ， 重起 MUX ， 观察 PVC 的 恢复 情况 ， 结果 DLCI 值为 16 、 234 和 991 的 PVC 正 
 
 确 恢复 ， 而 DLCI = 126975 的 PVC 恢复 的 数据 错误 为 61439 ， 而 DLCI = 1234567 的 PVC 完全 没有 恢 
 
 复 。 
                 对于 17 / 4 类型 ， DLCI = 126975 的 PVC 在 恢复 时 变成 61439 ， 根据 这 条 线索 ， 查找 原因 
 
 ， 发现 126975 - 61439 = 65535 ， 转化 二进制 就是 10000000000000000 ， 也就是说 在 数据恢复 或 
 
 保存 时 把 原 数据 的 第一个 1 给 忽略 了 。 此时 第一个 想法 是 ： 在 程序处理 中 ， 把 无 符号长 整型 
 
 变量 当作 短 整型 变量 处理 了 ， 为了 证实 这个 判断 ， 针对 17bit / 4bytes 类型 又 重新 设计 测试 
 
 用例 ： （ 1 ）   先建 PVC ， DLCI = 65535 ， 然后 保存 ， 重起 MUX ， 观察 PVC 的 恢复 情况 ， 发现 PVC 
 
 能够 正确 恢复 ； 
 （ 2 ） 再建 PVC ， DLCI = 65536 ， 然后 保存 ， 重起 MUX ， 观察 PVC 的 恢复 情况 ， 此时 PVC 不能 正确 
 
 恢复 。 
 至此 基本 可以 断定 原因 就是 出 在 这里 。 带 着 这个 目的 查看 原代码 ， 发现 在 以下 代码 中有 问 
 
 题 ： 
 int 	 _ GetFrDlci (   DWORD *   dwDlci ,   char *   str ,   DWORD   dwDlciType ,   DWORD   dwPortType ,   
 
 DWORD   dwSlotID ,   DWORD   dwPortID ) 
 {                     DWORD     tempDlci ; 
 	 char 	 szArg [ 80 ] ; 
 	 char 	 szLine [ 80 ] ; 
 	 ID 	 LowPVCEP ; 
                         DWORD 	 dwDlciVal [ 5 ] [ 2 ]   = 
       	 	 {   { 16 , 1007 } ,   { 16 , 1007 } ,   { 1024 , 64511 } , 
       	 	     { 2048 , 129023 } ,   { 131072 , 4194303 }   }   ; 
                         ． ． ． 
 } 
 
 typedef   struct   tagFrPppIntIWF 
 { 
 	 ． ． ． 
 	 WORD 	 wHdlcPort ; 
 	 WORD 	 wHdlcDlci ;             
 	 WORD 	 wPeerHdlcDlci ;       
 	 WORD 	 wPeerOldAtmPort ; 
 	 ． ． ． 	 
 } 	 SFrPppIntIWFData ; 
 
 DWORD   	 SaveFrNetIntIWFData   (   DWORD   * pdwWritePoint   ) 
 { 
 	 BYTE 	 bSlotID ,   bPeerSlotID ; 
 	 DWORD 	 dwCCID ,   dwPeerCCID ; 
 	 WORD 	 wHdlcPort ,   wAtmPort ,   wIci ,   wPeerIci ,   wPeerHdlcPort   ; 
 	 WORD 	 wCount ; 
                         ． ． ． 
 } 
 
 DWORD   	 SaveFrNetExtIWFData   (   DWORD   * pdwWritePoint   ) 
 { 
 	 BYTE 	 bSlotID ; 
 	 DWORD 	 dwCCID ,   dwPeerCCID ; 
 	 WORD 	 wHdlcPort ,   wAtmPort ,   wIci   ; 
 	 WORD 	 wCount ; 
 	 ． ． ． 
 unSevData . FrNetExtIWF [ wCount ] . bSlotID 	 =   bSlotID ; 
 	 unSevData . FrNetExtIWF [ wCount ] . wHdlcPort 	 =   wHdlcPort ; 
 	 unSevData . FrNetExtIWF [ wCount ] . wHdlcDlci 	 =   gFrPVCEP [ bSlotID   ] [   gFrPVCC [ bSlotID 
 
 ] [ dwCCID ] . dwLoPVCEP   ] . dwDLCI ; 
 	 unSevData . FrNetExtIWF [ wCount ] . wOldAtmPort 	 =   wAtmPort ; 
 	 unSevData . FrNetExtIWF [ wCount ] . wAtmDlci 	 =   gFrPVCEP [   bSlotID   ] [   gFrPVCC [ bSlotID 
 
 ] [ dwCCID ] . dwHiPVCEP   ] . dwDLCI ; 
 	 unSevData . FrNetExtIWF [ wCount ] . dwMapMode   =   gFrPVCC [ bSlotID ] [ dwCCID ] . dwMapMode ; 
 
 
 　 　 　 　 　 ． ． ． 
               } 
 
 
 DWORD   RestoreFrNetExtIWFData   (   WORD   wSlotID ,   BYTE   * pReadPoint   ) 
 { 
 	 WORD 	 wCount ,   wTotalNetIWF ; 
 	 BYTE 	 bSlotID ,   bHdlcDlciType ,   bAtmDlciType ; 
 	 WORD 	 wOldAtmPort ,   wAtmDlci ,   wHdlcPort ,   wHdlcDlci ;     
 	 DWORD 	 dwMapMode ,   dwCIR ,   dwBe ; 
 	 DWORD 	 dwCCID ,   dwResult ,   dwAtmPort ; 
 	 wTotalNetIWF   =   g _ MuxData . SevDataSize . wFrNetExtIWFNum ; 
 	 ． ． ． 
 } 
 
 DWORD   RestoreFrHdlcIntIWFData   (   WORD   wSlotID ,   BYTE   * pReadPoint   ) 
 { 
 	 WORD 	 wCount ,   wTotalHdlcIWF ; 
 	 DWORD 	 dwCCID ,   dwPeerCCID ,   dwAtmPort ,   dwPeerAtmPort ; 
 	 DWORD 	 dwResult ; 
 	 BYTE 	 bSlotID ,   bPeerSlotID ; 
 	 WORD 	 wHdlcPort ,   wOldAtmPort ,   wCIR ; 
 	 WORD 	 wPeerHdlcPort ,   wPeerOldAtmPort ; 
                         ． ． ． 
 } 
 
                 其中 涉及 DLCI 值 的 变量 都 为 WORD （ 即 无 符号 短 整型 ） 类型 ， 在 程序 的 处理 时 ， 出 
 
 现 WORD 和 DWORD （ 无 符号长 整型 ） 类型 在 一句 中 同时 存在 的 情况 ， 至此 可以 判断 问题 出 在 这 
 
 里 。 由于 DLCI 值 在 不同 类型 时 的 取值 范围 不同 ， 前 三种 类型 的 取值 范围 为 16 ~ 991 ， 第四种 
 
 取值 范围 为 2048 ~ 126975 ， 第五种 取值 范围 为 131072 ~ 4194303 ， 所以 当 采用 前 三种 DLCI 类型 
 
 时 ， 采用 WORD 类型 最大值 为 65535 ， 已经 完全 够用 了 ； 而 对于 第四种 类型 时 ， 其 取值 在 超过 
 
 65535 时 ， 获取 DLCI 值 的 函数 _ GetFrDlci （ ） 采用 DWORD 类型 ， 而 负责 保存 和 恢复 的 两个 函 
 
 数 SaveFrNetExtIWFData （ ） 和 RestoreFrNetExtIWFData （ ） ， 都 把 DLCI 的 值 当作 WORD 类型 
 
 进行 处理 ， 因此 导致 DLCI 取值 越界 ， 于是 程序 把 原本 为长 整型 的 DLCI 强制 转换成 整型 ， 从 
 
 而 导致 DLCI 值 在 恢复 时 ， 比原 数据 小 65536 。 而 在 程序运行 过程 中 ， 这些 数据 保存 在 DRAM 中 
 
 ， 程序运行 直接 从 DRAM 中 获取数据 ， 程序 不会 出错 ； 当 FRI 板 复位 或 插拔 后 ， 需要 从 FLASH 
 
 中 读取数据 ， 此时 恢复 函数 的 错误 就 表现 出来 。 
               另 一个 问题 是 为什么 23 / 4 类型 的 DLCI 数据 不能 恢复 ？ 这是 由于 对于 23 / 4 类型 的 PVC 
 
 ， 其 DLCI 的 取值 范围 为 ： 131072 ~ 4194303 ， 而 程序 强制 转换 并 恢复 的 数据 最大 只能 是 6553 
 
 5 ， 所以 这条 PVC 不能 恢复 。 
                 至此 ， DLCI 数据恢复 出错 的 原因 完全 找到 ， 解决 的 方法 是 将 DLCI 的 类型 改为 DWOR 
 
 D 类型 。 从 这个 案例 可以 看出 ， 在 程序开发 中 一个 很 低级 的 错误 ， 将 在 实际 工作 中 造成 很严 
 
 重 的 后果 。 
 
 5 、 正确 使用 逻辑 与 && 、 屏蔽 & 操作符 
 【 案例 1.5 . 1 】 
 【 案例 描述 】 ： 由于 C语言 中位 与 比求模 效率高 ， 因而 系统 设计 时 ， 对于 模 128 的 地方 都 改 
 
 为 与 127 ， 系统 定义 的 宏为 # define   MOD128     127 和 # define   W _ MOD         127 ( 定义 的 宏 的 名字 
 
 易 引起 误解 ) ， 但 实际 程序 中 还是 采取 求模 ， 从而 引起 发送窗口 欲 重发 的 和 实际 重发 的 不 一 
 
 致 ， 最终 导致 链路 复位 此类 严重 问题 ， 曾 在 定位 此 问题 时花 了 不少 时间 。 
 
 【 处理过程 】 ： 处理过程 如下 ： 
 # define           MOD128                     127     / / 队列 长 128 ， 当队 头 到 128 时 ， 上 其 返回 。 
 # define         W _ MOD                       127   / / 发送窗口 队列 ， 意义 同 上 。 
 在 函数 L2 _ TO _ L1 ( ) 中 ， 有 如下 语句 ： 
                 linkstate _ ptr - > SendWin . head   =   ( head   +   1 )   %   W _ MOD   ; 
 这里 当 head = 126 时 ， SendWin . head   =   0 ， 这 将 造成 发送窗口 指针 和 队列 窗口 指针 错位 ， 造 
 
 成 链路 复位 ; 
 另外 ， 在 重发 函数 void   INVOKE _ RETRANSMISSION ( _ US   logic _ link , _ US   n _ r ) 中 ， 有 如下 语 
 
 句 ： 
                 retran _ num   =   ( LinkState [ logic _ link ] . Vs   +   MOD128     -   ( _ UC ) n _ r )   %     MOD128 
 
   ; 
                 w _ head   =   ( LinkState [ logic _ link ] . SendWin . head   +   W _ MOD     -   retran _ num )   %   
 
 W _ MOD   ; 
 第一个 语句 求欲 重发 的 消息 包 个数 ， 第二个 语句 求 重发 的 起始 位置 ， 当 Vs 小于 n _ r 时 ， 将造 
 
 成 实际 重发数 小于 欲重 发数 ， 同时 造成 实际 起始 重 发 位置 和 欲 重 发起 始 位置 错开 ， 从而 引 
 
 起 链路 复位 。 上面 三个 语句 应该 做 如下 改动 ： 
                 linkstate _ ptr - > SendWin . head   =   ( head   +   1 )   &   W _ MOD   ; 
 
                 retran _ num   =   ( LinkState [ logic _ link ] . Vs   +   MOD128     +   1   -   ( _ UC ) n _ r )   &     MO 
 
 D128   ; 
                 w _ head   =   ( LinkState [ logic _ link ] . SendWin . head   +   W _ MOD   +   1   -   retran _ num ) 
 
   &   W _ MOD   ; 
 【 结     论 】 ： 由于 链路 通信 对系统 效率 要求 很 高 ， 算法 采用 效率 最高 的 ， 但位 与 （ & ） 和 求 
 
 模 （ % ） 这 小小的 区别 ， 造成 的 竟是 链路 复位 这种 严重 的 错误 。 
 
 【 思考 与 启示 】 ： 对 这类 问题 ， 大家 在 阅读 代码 或 代码 审查 时 一定 要 注意 ， 仔细 一点 往往 
 
 能 发现 问题 ， 但 在 测试 中来 定位 这种 问题 ， 花费 的 时间 往往 更长 。 
 
 6 、 注意 数据类型 的 匹配 
 【 案例 1.6 . 1 】 
 【 案例 描述 】 
 	 下面 通过 测试 中 的 一个 例子 来 说明 这个 问题 ： 命令 DSP   N7C 是 用来 显示 NO7 电路状态 的 ， 其 
 
 参数 设备 类型 DID 支持 TUP 和 ISUP ， 参数 信道 号 BSN 支持 多值 输入 （ 最 多 支持 32 路 查询 ） ， 正 
 
 常 情况 下该 命令 没有 问题 。 但试 了 非正常 情况 下 ， 问题 就 出来 了 。 
 	 1 、 首先 试 BSN 参数 越界 情况 ， 即 参数 BSN 超过 32 路 查询 ， 选 了 几个 数据 段 ， 问题 就 出来 了 
 
 。 对于 0 && 300 和 0 && 256 ， 该 命令 返回 结果 不 一致 ， 对 前者 认为 参数 越界 ， 对 后者 返回 执行 
 
 成功 。 
 	 2 、 对于 参数 DID ， 选定 一种 设备 类型 （ TUP 或 ISUP ） ， 让 参数 BSN 所 包含 的 32 路电路 跨越 T 
 
 UP 和 ISUP ， 两次 结果 是 不 一致 的 。 
 【 处理过程 】 
 	 反馈 到 开发人员 那里 ， 第一个 问题 是 BAM 的 问题 ， 第二个 问题 是 SM 的 问题 。 
 【 结     论 】 
 	 1 、 为 数据 超出范围 溢出 造成 ， int 值 赋值 给 BYTE ， 造成 数据 丢失 。 
 	 2 、 问题 的 产生 是因为 查询 的 第一个 信道 是 TUP 电路 ， 但是 却 按 ISUP 电路 查询 。 ISUP 的 维护 
 
 处理函数 判断 第一个 信道 不是 ISUP 信道 ， 认为 整个 的 PCM 不是 ISUP 类型 的 PCM ， 返回 全部 的 
 
 电路状态 为 未 安装 。 消息 处理 不合理 。 TUP 也 会 产生 如此 错误 。 
 
 【 思考 与 启示 】 
 	 我们 的 MML 命令 并 不是 无懈可击 的 ， 许多 表面 上 的 小 问题 ， 往往 隐藏 着 代码 的 缺陷 和 错误 
 
 。 
 
 【 案例 1.6 . 2 】 
 【 正                         文 】 
 当 我们 使用 PC - LINT 检查 代码 时 ， 会 发现 大量 的 数据类型 不 匹配 的 告警 ， 大部分 情况 下 ， 这 
 
 种 代码 上 存在 的 问题 并 不会 引起 程序 功能 实现 上 的 错误 ， 但 有些 情况 下 ， 也许 会 产生 严重 
 
 的 问题 ： 
 
               一 、 不同 数据类型 变量 之间 赋值 引起 的 问题 ， 实际上 ， 该类 问题 也 可以 分为 几种 情 
 
 况 ： 
 1 、 直接 赋值 ， 比如 ， 把 一个 WORD 型 变量 赋给 一个 INT 型 变量 ， 如果 WORD 型 变量 大于 32767 ， 
 
 INT 型 变量 得到 的 就是 一个 负值 了 。   
 【 例一 】 一次 测试 过程 中 发现 ， SDH 送 的 告警 在 BAM 调试 窗口 打印 出 红色 提示 ： File ( XXX ) , 
 
 Line ( XXX ) : Invalid   alarm   id   , from :   7 ,   AlarmId :   65463 
 经过 检查数据 发现 ， 并 没有 ID 为 65463 的 告警 ， 分析 上报 的 数据 帧 ， 发现 上报 的 告警 ID 为 B 
 
 7 ， 原来 代码 中有 一处 强制 类型转换 ： 
                         sdhAlmStru . AlarmId   =   ( WORD ) RecvBuffer [ iTmpLen   +   5 ] ; 
 char 型 强制 转换成 WORD 型 。 B7 就 变成 了 FFB7 ， 十进制 就是 65463 。 由于 char 是 有 符号 型 ， B 
 
 7 的 第 8 位为 1 ， 所以 转换 后 为 FFB7 ， 而 不是 代码 作者 希望 的 00B7 ， 如果 第 8 位是 0 ， 或 该 变量 
 
 是 BYTE 型 ， 转换 就 不会 有 问题 了 。 
 2 、 函数 形参 和 实参 不 一致 ， 实际上 和 第一种 情况 本质 上 是 一样 的 ， 只是 表现 的 形式 不太一 
 
 样 ， 这种 情况 也 是 代码 中 经常出现 的 问题 , 下面 例子 是 测试 中 曾经 发现 的 一个 小 问题 ： 
 【 例二 】 在 file01 中 的 INT   DebugMsgProc ( char   byMsg0 ,   char   byMsg1 ) 函数 ， 两个 形参 都 
 
 是 char 型 ， 而 实际 传入 的 参数 都 是 BYTE 型 ， 结果 函数 中 的 如下 语句 ： 
 PrintfE ( PID _ RED , "   % d   ticks   time   out ! " , byMsg1 ) ; 
 在 byMsg1 大于 127 时 ， 输出 错误 的 结果 。 
 
         二 、 不同 数据类型 之间 的 比较 操作 
 
 在 循环 终止 条件 的 判断 中 ， 不同 类型 变量 的 比较 操作 是 容易 造成 死循环 错误 的 地方 ， 同时 
 
 也 是 开发人员 容易 忽视 的 地方 ， 值得 测试人员 多加 留意 。 下面 两个 例子 是 该类 错误 的 两种 
 
 典型 情况 ： 
 【 例三 】 file02 文件 中 某 函数 中 如下 代码 ， 可能 造成 死循环 ： 
                   ...... 
                         int   i ; 
 	 WORD   * pCheck     = ( WORD * ) p ; 
 	 WORD   wCheckSum = * pCheck ; 
 	 pCheck ++ ; 
 
 	 for ( i = 1 ; i < dwLen / 2 ; i ++ ) 
 	 { 
 	 	 wCheckSum ^ = ( * pCheck ) ; 
 	 	 pCheck ++ ; 
 	 } 
 	 / / binlen   had   already   word   alignment 
 	 return   ( wCheckSum ) ; 	 	 
 	 ...... 
       该段 代码 是 在 DOS 环境 下用 BC 编译 的 ， 由于 循环 变量 i 是 int 型 （ 2 个 字节 ） ， 而 dwLen 是 
 
 DWORD 型 （ 4 个 字节 ） ， 如果 dwLen 大于 65536 ， 那么 该 函数 就是 死循环 了 。 
 
 上面 的 例子 是 不同 类型 变量 之间 直接 比较 操作 ， 还有 一种 情况 是 函数 的 返回值 与 另 一 不同 
 
 类型 的 变量 比较 ， 见 下面 例子 ： 
 【 例四 】 file03 . c 文件 中 某 函数 中 如下 代码 ， 
           	 	 while (   ftell ( fp ) <   Part [ 3 ] ) 
 	 	 { ..... 
                                                   } 	 
     ftell 返回 long 型 ， 而 Part 是 DWORD 型 ， 有 符号 变量 和 无 符号 变量 的 比较 ， 可能 造成 死循 
 
 环 。 
 
 类似 的 例子 还有 很多 ， 类型 不 匹配 的 问题 还有 许多种 情况 ， 都 是 代码 中 的 隐患 ， 有时 会造 
 
 成 严重 的 后果 ， 需要 引起 足够 的 重视 。 对于 该类 问题 ， 我们 可以 利用 PC - LINT 工具 对 代码 进 
 
 行 细致 的 检查 。 
 
 7 、 用于 控制 条件 转移 的 表达式 及 取值 范围 是否 书写 正确 
 【 案例 1.7 . 1 】 
 【 案例 描述 】 ： 
 	 在 测试主机 MPU 板 倒换 功能 时 ， 如果 MPU 备份 充分 ， 倒换 前后 对 处于 激活状态 的 电路 应 无影 
 
 响 ， 即 不 影响 通话 。 但 近期 测试 发现 ， 如果 两局 通过 DT 板 进行 一号 对接 ， MPU 备份 倒换 却发 
 
 生断 话 。 具体 现象 为 ： 如果 DT 板 的 第 1 个 PCM 系统 电路 为 故障 ， 则 MPU 倒换 时 复位 该 DT 板 ， 如 
 
 果 DT 板 的 第 2 个 PCM 系统 电路 为 故障 ， 则 MPU 倒换 时 复位 下 一块 DT 。 
 
 【 处理过程 】 ： 
 	 据查 ， MPU 倒换 时会 自动 复位 处于 “ 故障 ” 态 的 电路 ， 但 由于 计算错误 （ 多加 了 32 ） ， 错 
 
 复位 了 下 一个 PCM 系统 32 路电路 。 
 【 结     论 】 ： 
 	 如此 严重 问题 为什么 到 今天 才 发现 ？ 因为 我们 在 实验室 中 一般 采用 同一 单板 的 2 个 PCM 系统 
 
 自环 进行 测试 ， 则 不会 在 某 单板 上 有 故障 和 空闲 电路 共存 ， 自环 屏蔽 了 错误 。 
 【 思考 与 启示 】 ： 
 	 自环 是 在 测试环境 下 常用 的 一种 提高效率 的 手段 ， 但 一旦 条件 允许 ， 我们 的 测试 工作 应 尽 
 
 量 模拟 网上 的 实际 环境 进行 。 
 
 【 案例 1.7 . 2 】 
 	 平时 对 计费 功能 进行 测试 的 时候 ， 浏览 详细 话单 都 是 比较 注意 话单 本身 的 正确性 ， 并 没有 
 
 注意 该 命令 对系统 的 影响 。 所以 当 浏览 少量 话单 的 时候 ， 并 没有 发现 该 命令 的 异常 。 但是 
 
 当 时间 的 跨度 较大 时 ， 详细 话单 数量 较 多 ， 问题 就 出现 了 。 执行 如下 命令 ： 
 	 LST   AMA :   TP = NRM ,   SD = 1999 & 7 & 1 ,   SA = YES ; 
 	 当 浏览 了 大约 10 万张 详细 话单 后 ， 终端 与 BAM 的 连接 关闭 。 重建 连接 后 ， 发现 话单 台 的 命 
 
 令 不能 执行 。 观察 BAM 的 性能 ， 发现 话单 台 仍 占有 CPU50% 以上 的 利用率 ， 说明 原来 的 任务 仍 
 
 在 执行 。 需要 关 一下 话单 台 才能 恢复正常 。 
 	 重复 上述 步骤 ， 当 终端 与 BAM 的 连接 尚未 关闭 时 主动 断开 此次 连接 ， 结果 同 上 。 
 	 反馈 到 开发人员 那里 ， 发现 该 现象 与 设计 的 初衷 是 相 违背 的 。 本来 话单 台 控制 最 多 输出 2 
 
 00 张 话单 ， 这是 为了 防止 过多 话单 的 输出 显示 会 增加 BAM 的 开销 ， 从而 降低 BAM 的 性能 。 查 
 
 看 一下 源代码 ， 问题 就 发现 了 。 
 	 话单 台 控制 最 多 输出 200 张 话单 
 程序 如下 
         while ( timeCur   < =   timeEnd ) 
         { 
 	 timeCur   + =   tsOneDay ; / / 加 一天 
 
 	 while ( fileBill . Read ( & rpt ,   sizeof ( CBillReport ) )   = =   
 	 	 sizeof ( CBillReport ) ) 
 	 { 
                                   ..................... 	 
                                                   / / 只 输出 满足条件 的 前 200 张 话单 
 	                   if   ( ++ wBillCount   = =   200 ) 
 	                 { 
 	 	 break ; 
 	                 } 
 	 } / / 一个 文件 查询 结束 
       } / / 所有 文件 查询 结束 
 
 	 在 话单 输出 200 张 之后 ， 程序 只 退出 一层 循环 ， 仍然 会 从 下 一天 话单 继续 输出 ， 导致 向 MM 
 
 L 发帧 过 多 ， 造成 MML 和 话单 台 都 被 堵死 。 
 	 修改 ProcessQueryBill ( ) 函数 
           / / 只 输出 满足条件 的 前 200 张 话单 
           if   ( ++ wBillCount   = =   200 ) 
           { 
                   	 timeCur   =   timeEnd   +   tsOneDay ; / / 退出 第二层 循环 , 
 	 	 while ( timeCur   < =   timeEnd ) 
 	 	 	 break ; 
           }                 
 	 作 上述 修改 后 问题 就 不再 出现 了 。 
 	 一些 MML 命令 从 完成 的 功能 来讲 可能 是 没什么 问题 的 ， 但 其 执行 对系统 性能 的 影响 我们 在 
 
 测试 时时 往往 给 忽视 了 。 在 我们 目前 的 BAM 方案 中 ， 存在 着 多个 终端 协同工作 ， 如果 某个 终 
 
 端 发出 的 命令 在 BAM 中 长时间 独占 着 大部分 系统资源 ， 造成 的 后果 是 严重 的 。 这 是 在 设计 时 
 
 要 避免 的 ， 在 测试 中要 注意 的 问题 。 
 
 【 案例 1.7 . 3 】 
 【 正                         文 】 
 	 在 判断 模拟 用户 端口 是否 反 极性 时有 这样 一段 程序 ：     
             	 if   (   (   bsn   > =   g _ wASL32StartPSN   )   &&   
                       (   (   (   bsn   -   g _ wASL32StartPSN   )   %   32   )   = =   15     | |     (   (   bsn   -   g _ wASL32 
 
 StartPSN   )   %   32   = =   16   )   )   ) 
 	 	 	 return   TRUE ; 
   	 if   (   (   bsn   %   16   )   = =   7   | |   (   bsn   %   16   )   = =   8   ) 
 	 	 	 return   TRUE ;   
 	   	 return   FALSE ; 
 
 	 作者 的 本意 是 如果 是 32 路 用户 板 （ 蓝色 字体 判断 ） ， 就 看 端口号 是否是 第 15 和 16 路 ， 如果 
 
 是 ， 就是 反 极性 端口 ， 返回 TRUE ， 否则 就 不是 ， 应该 返回 FALSE 。 但 代码 表达 的 意思 是 ： 如 
 
 果是 32 路 用户 板 并且 端口号 是 15 或 16 就 返回 真值 ， 否则 还要 执行 下边 语句 。 
 	 当 端口 在 32 路 用户 板上 ， 但 端口号 不是 15 或 16 时 ， 不同 的 32 路 端口 的 起始 地址 g _ wASL32S 
 
 tartPSN ， 会 导致 不同 的 非 15 、 16 端口 被 误认为 是 反 极性 端口 。 举个 例子 ， 当 g _ wASL32Sta 
 
 rtPSN 的 值 为 3000 时 ， 端口号 为 3000 （ 第一块 板上 的 第 0 个 端口 ） 就 被 认为 是 反 极性 端口 ， 
 
 这 与 作者 的 意图 完全 相悖 。 
 	 可以 将 代码 修改 如下 ：     
         	 if   (   (   bsn   > =   g _ wASL32StartPSN   )   
 	 	 { 
 	 	 	 if     (   (   (   bsn   -   g _ wASL32StartPSN   )   %   32   )   = =   15     | |     (   (   bsn   -     g _ wASL32Sta 
 
 rtPSN   )   %   32   = =   16   )   )   ) 
 	 	 	 return   TRUE ; 
 	 	 } 
   	 	 
 	   else 
 	 	 if   (   (   bsn   %   16   )   = =   7   | |   (   bsn   %   16   )   = =   8   ) 
 	 	 	 return   TRUE ;   
 	 return   FALSE ; 
 	 通过 这个 例子 ， 我 觉得 在 代码 审查 时 应该 留意 在 判断 条件 较 多 的 情况 下 ， 每个 输入 是否 都 
 
 能 正确 输出 ， 在 单元测试 、 集成 测试 、 系统 测试 时要 针对 边界值 设计 相应 的 测试用例 。 
 
 
 	 判断 条件 较多时 开发人员 也 应该 适当 分开 写 ， 既 使 代码 更 易读 ， 又 不 容易 出错 。 
 
 8 、 条件 分支 处理 是否 有 遗漏 
 【 案例 1.8 . 1 】 
 【 现     象 】 
                 在 接入网 主机 程序 的 代码 审查 中 ， 发现 dbquery . c 的 DBQ _ Init _ ANType 函数 中 如下 
 
 代码段 缺少 应有 的 条件 分支 ， 在 数据 异常 的 情况 下 ， 会 产生 较 严重 的 问题 。 
 
 【 处理过程 】 
                   该 错误 比较 隐蔽 ， 现在 说明 如下 ： 
                   Max2B1QStatTime   最大 统计 时间 
                   Max2B1QStatPortNum 最大 统计 端口数 
                   MAX _ 2B1Q _ STAT _ PSN               最大 统计 内存 分配 数量   
                 其中 ： Max2B1QStatTime （ 最大 统计 时间 ） 和 Max2B1QStatPortNum 
 （ 最大 统计   端口数 ） 的 乘积 不能 大于 MAX _ 2B1Q _ STAT _ PSN 
 
                   程序 如下 ： 
                     / / 查询数据库 ， 获得 Max2B1QStatTime 的 值 
 	 directQueryCond . tupleNo   =   10 ; 
 	 error _ code   =   DB _ Query (   RID _ OTHERS _ PARA _ INFO ,   1 , 
 	 	 	 	 	 	       ( LPDBCondition ) & directQueryCond , 
 	 	 	 	 	 	       ( BYTE   FAR   * ) & tempstruct0   ) ; 
 	 / / 查询数据库 成功 
 	 if (   error _ code   = =   DB _ SUCCESS   ) 
 	 { 
 	 	 / / tempstruct0 . data 是 数据库 中为 Max2B1QStatTime 配置 的 值 
 	 	 if   (   tempstruct0 . data   >   MAX _ 2B1Q _ STAT _ PSN   ) 
 	 	 	 Max2B1QStatTime   =   MAX _ 2B1Q _ STAT _ PSN ; 
 	 	 else   if   (   tempstruct0 . data   ! =   0   ) 
 	 	 	 Max2B1QStatTime   =   tempstruct0 . data ; 
 	 } 
 
                     / / 查询数据库 ， 获得 Max2B1QStatPortNum 的 值 
 	 directQueryCond . tupleNo   =   11 ; 
 	 error _ code   =   DB _ Query (   RID _ OTHERS _ PARA _ INFO ,   1 , 
 	 	 	 	 	 	       ( LPDBCondition ) & directQueryCond , 
 	 	 	 	 	 	       ( BYTE   FAR   * ) & tempstruct0   ) ; 
 	 / / 查询数据库 成功 
 	 if (   error _ code   = =   DB _ SUCCESS   ) 
 	 { 
 
 	       / / tempstruct0 . data 为 数据库 中为 Max2B1QStatPortNum 配置 的 值 ， 如果 其 缺省值 和 Ma 
 
 x2B1QStatTime 乘积 值 大于 MAX _ 2B1Q _ STAT _ PSN 的话 ： 
 	       if   (   ( tempstruct0 . data   *   Max2B1QStatTime )   >   MAX _ 2B1Q _ STAT _ PSN   )                     
 
 
                                             	 Max2B1QStatPortNum   =   MAX _ 2B1Q _ STAT _ PSN   /   Max2B1QStatTim 
 
 e ; 
 
                             / / 如果 在 合理 范围 内且 不为 0 的话 ： 
                             else   if   (   tempstruct0 . data   ! =   0   )     
 	 	 Max2B1QStatPortNum   =   tempstruct0 . data ; 
 	 } 
 
                 此处 if - else   if   分支 没有 判断   值为 0 的 情况 ， 即 数据库 为 Max2B1QStatPortNum 配 
 
 置 的 值 为 0 ：   tempstruct0 . data   = =   0 ， 则 Max2B1QStatPortNum 就 为 缺省值 32 。 
 
 【 结     论 】 
                 由于 内存 限制 ， Max2B1QStatTime （ 最大 统计 时间 ） 和 Max2B1QStatPortNum （ 最大 
 
 统计 端口数 ） 的 乘积 不能 大于 MAX _ 2B1Q _ STAT _ PSN ， 
                 如果 从 数据库 中 得到 Max2B1QStatTime 为 MAX _ 2B1Q _ STAT _ PSN ， 而 数据库 中 最大 统 
 
 计 端口数 恰好 为 0 ， 由于 上述 代码 没有 对 tempstruct0 . data   = =   0 的 情况 进行 判断 ， Max2B1 
 
 QStatPortNum 为 缺省值 32 ， 这样 Max2B1QStatTime 和 Max2B1QStatPortNum 乘积 已经 是 32 倍 M 
 
 AX _ 2B1Q _ STAT _ PSN 了 ， 远远 超过 了 设计 内存 的 限制 。 
                   造成 这种 错误 的 原因 是 判断 语句 对 条件 判断 不 完整 。 
 
 【 思考 与 启示 】 
                 在 代码 审查 时 ， 应该 十分注意 条件 判断 的 的 完备 性 。 好多 问题 就是 因为 条件 判断 
 
 不 完全 造成 的 。 
 
 
 9 、 引用 已 释放 的 资源 
 【 案例 1.9 . 1 】 
 【 正                         文 】 
 	 在 计费 测试 的 过程 中 ， 用 呼叫器 进行 大 话务量 呼叫 测试 。 30 路话 路 通过 TUP 自环 呼叫 另外 
 
 30 路话 路 ， 计费数据 的 设定 是 这样 的 ： 通过 计费 情况 索引 对 主叫 计费 ， 得到 详细 话单 。 首 
 
 先 保证 计费数据 设定 的 正确性 ， 打 了 几次 自环 电话 后 ， 查看 话单 正常 ， 则 开始 呼叫 。 
 呼叫 几万 次后 停止 呼叫 ， 取 话单 进行 观察 。 发现 这 30 路 每次 呼叫 总会 出现 一张 告警 话单 ， 
 
 其余 话单 正常 ， 该 告警 话单 相对 于 话 路 来说 是 随机 出现 的 。 
 	 通知 开发人员 后 ， 首先 我们 再次 对 计费数据 进行 了 确认 。 某个 用户 在 某 次呼叫 产生 了 告警 
 
 话单 ， 其上 一次 和 下 一次 呼叫 的 计费 情况 都 正常 ， 两次 呼叫 之间 的 时间 间隔 只有 几秒钟 ， 
 
 排除 了 人为 修改 数据 的 可能 。 开发人员 认为 是 CCB 的 问题 ， 后来 一查 果然如此 。 
 	 当中 继 选线 发生 了 同 抢 需要 重新 选线 时 ， CCB 的 reset _ CCB _ for _ reseatch _ called _ locati 
 
 on ( ) 就 会 把 有关 的 呼叫 信息 清掉 ， 造成 计费 情况 分析 失败 ， 产生 计费 费用 为 0 的 告警 话单 。 
 
 
 	 更正 reset _ CCB _ for _ reseatch _ called _ location ( ) 中 清除 被叫 信息 的 代码 ， 重选 中继 时 不 
 
 清除 被叫 用户 这部分 属性 。 
 	 思考 与 启示 ： 
 	 1 、 在 计费 测试 过程 中 ， 对话 单 的 观察 很 重要 ， 不 应该 放过 任何 一个 细小 的 疑点 ； 
 	 2 、 计费 测试 仅仅 打 几次 电话 往往 达 不到 效果 ， 越 接近 用户 实际 使用 的 情况 越 可能 发现 问 
 
 题 。 
 
 【 案例 1.9 . 2 】 
 【 案例 描述 】 
                 在 进行 128 模块 V5 用户 CENTREX 新 业务 测试 时 ， 偶然 遇到 一个 怪现象 ： 对 群内 一个 
 
 V5ST 用户 只 开放 MCT 权限 ， 在 进行 恶意 呼叫 追查 时 ， 有 一次 报 恶意 呼叫 追查 成功 音只 报 了 一 
 
 半 ， 当 正要 报出 恶意 呼叫 的 号码 时 ， 业务 中断 重新 回到 通话 态 ， 随即 重新 追查 一次 ， 报 “ 
 
 已 申请 其它 新 业务 ， 本次 申请 不 成功 ” 。 恶意 呼叫 追查 与 任何 新 业务 都 不会 冲突 ， 而且 此 
 
 用户 也 只有 恶意 呼叫 追查 有权 ， 可以 肯定 此时 程序 出 问题 了 。 为了 重现 ， 再次 挂机 ， 重新 
 
 呼叫 ， 应用 此新 业务 ， 但 这个 现象 一直 没有 出现 。 大约 反复 操作 20 遍 ， 又 出现 了 一次 这样 
 
 的 情况 ， 显然 程序 中 可能 存在 某种 问题 。   
 
 【 处理过程 】 
                 出现 这个 问题 后 ， 及时 与 开发人员 A 取得 了 联系 ， 并 一起 试图 重现 这个 问题 ， 通过 
 
 许多次 的 反复 操作 ， 又 出现 了 一次 这种 情况 。 确认 问题 后 ， A 表现 出 高度 的 责任心 ， 马上 驾 
 
 调试 环境 ， 反复 调测 ， 终于 在 当天 就 逮住 了 狐狸尾巴 ： 
                 1 、 当 用户 接听 恶意 呼叫者 的 电话 ,   并 启动 恶意 呼叫 追查 业务 后 ,   在 V5 _ CR _ VOICE 
 
 TONE 状态 下 ,   只要 听 MCT 音 的 用户 用 脉冲 方式 拨 任意 一个 数字 ,   则 立即 停止 送 MCT 音 ,   而 将 
 
 用户 切换 回 与 恶意 呼叫者 的 通话 .     但是 程序 中 没有 对 拨号 类型 作 判断 ,   导致用户 若用 音频 
 
 拨号 也 会作 同样 的 处理 。 
                 2 、 除了 取消 此次 MCT 服务 ,   将 用户 切换 回 与 恶意 呼叫者 的 通话 外 ,     如果 不 释放 M 
 
 CT _ HANDLE ,   由于 每个 模块 只有 一个 这样 的 资源 ,     则 下 一次 使用 MCT 业务 的 用户 不能 成功 , 
 
   因为 会 在 申请 MCT _ HANDLE 时 失败 ,   V5 模块 和 ST 模块 在 这个 地方 处理 都 有 问题 ,   没有 将 MCT 
 
 _ HANDLE 释放 掉 ,     对于 V5 用户 会 听 新 业务 失败 音 ,   对于 ST 用户 会 听 音乐 。 
                 当 不停 的 拨测 V5 用户 的 MCT 业务 时 ,   有时 在 听音 时 ,   可能 由于 网板 有 杂音 等 原因 ( 
 
 或 用户 碰 了 话机 的 按键 ) ,     导致 DTR 收到 一位 号 ,   则 会 立即 停止 此次 MCT 服务 ,   用户 会 听到 
 
 MCT 送音 突然 中断 ,   然后 恢复 了 与 恶意 呼叫者 的 通话 .   而 下次 再用 MCT 时 ,   由于 上面 所述 的 
 
 原因 ,   会 听到 新 业务 失败 音 ,   此次 失败 后 ,   无论 MCT _ HANDLE 分配 成功 与否 ,   该 用户 的 MCT 标 
 
 志 都 被 置 为 1 ,   所以 在 用户 挂机 时 ,   会 将 该 模块 唯一 的 MCT _ HANDLE 资源 释放 掉 .   则 以后 该功 
 
 能 又 可以 正常 实现 。 
                 在 追查 这个 问题 时 ， 开发人员 A 又 发现 了 一个 可能 导致 死机 的 严重 问题 ： 在 用户 启 
 
 动 MCT 服务 ,   正在 听报 追查 号码 的 MCT 音时 ,   若 恶意 用户 此时 挂机 ,     CCB 的 处理 中 ,   只 针对 
 
 ST 用户 送 DISCONNECT ,   而 对 V5ST 用户 送 的 是 RELEASE 消息 ,   这 导致 V5X 收到 此 消息 后 ,   将 该 
 
 V5ST 用户 的 cr2 清除 掉 ,   V5 _ USER _ TALBE [     ] .   cr2 变为 0xFFFF ,   这样 在 V5 _ CR _ VOICETONE 超 
 
 时后 ,     程序 中 会 检查 cr2 的 状态 是否 为 HOLD ,   当取 cr2 的 内容 时 ,   由于 cr2 已 被 清除 ,   会发 
 
 生 指针 越界 的 GP 错误 。 
   
 【 结     论 】 
                 通过 调测 发现 、 定位 并 解决问题 。 
 
 【 思考 与 启示 】 
                 我们 平常 一些 熟视无睹 的 业务 或 按 正常 流程 操作 没有 问题 的 业务 ， 不能 保证 它 就 
 
 一定 没有 问题 ， 要 善于 抓住 一丝一毫 的 异常现象 。 对于 很难 重现 的 问题 千万 不要 轻易 放过 
 
 ， 我们 网上 设备 所出 的 问题 很多 都 是 一些 在 实验室 难以 出现 或 很 难 重现 的 一些 问题 ， 一些 
 
 显而易见 的 问题 一般 都 可 消灭 在 实验室 ， 难 就 难 在 消灭 一些 隐藏 很深 的 问题 。 说老实话 ， 
 
 我们 的 产品 还有 许多 问题   ， 需要 我们 扎扎实实 锲而不舍 的 工作 。 
 
 10 、 分配资源 是否 已 正确 释放 
 【 案例 1.10 . 1 】 
 【 正                         文 】 
                     在 对 接入网 A 产品 的 网管软件 测试 中 ， 发现 了 一个 WINDSOWS 资源 损耗 的 的 问题 ： 
 
 当 网管软件 运行 几天 后 ， WINDOWS 总会 出现 “ 资源 不够 ” 的 告警 提示 。 如果 网管软件 不 关掉 
 
 再 重新启动 的话 ， 就 会 出现 WINDOWS 资源 完全 耗尽 的 现象 ， 最终 网管 系统 反应 很 慢 ， 无法 正 
 
 常 工作 。 
 	 从 现象 上 可以 判断 出 ， 网管软件 存在 隐蔽 的 内存 泄露 或 资源 不 释放 的 问题 ， 并且 这种 资源 
 
 耗尽 是 一个 缓慢 的 过程 。 如何 定位 这个 问题 呢 ？                   
 	 定位 这种 问题 可以 利用 WINDOWS 中 的 一个 系统资源 监视 工具 。 打开 Windows 的 “ 附件 / 系统 
 
 工具 / 资源 状况 ” ， 这是 一个 系统资源 、 用户 资源 、 和 GDI 资源 的 实时 监视 工具 。 
 	 工具 有 了 ， 那么 如何 发现 导致 不断 消耗 资源 的 特定 操作 呢 ？ 
 	 首先 和 开发人员 共同 探讨 ， 列出 几个 最 可能 消耗 资源 的 操作 和 一些 操作 组合 ， 这样 就 缩小 
 
 了 监视 范围 ， 避免 没有 范围 的 碰运气 ， 否则 如 大海捞针 。 
 	 监视 前 ， 首先 重新启动 WINDOWS ， 最好 不 运行 其他 的 程序 ， 打开 “ 系统 状况 ” 这个 监视 工 
 
 具 ， 然后 运行 网管软件 ， 记下 此时 的 资源 状况 数据 。 
 	 然后 针对 一个 可疑 的 操作 ， 快速 大量 地 重复 进行 。 这种 重复性 的 操作 可以 利用 QArun 测试 
 
 工具 执行 ， QArun 可以 记录 操作者 的 一次 操作步骤 ， 然后 按照 设定 的 次数 重复 操作 。 操作 后 
 
 ， 观察 此时 的 资源 状况 ， 并 记下 此时 的 数据 ， 与 操作前 的 数据 比较 ， 如果 操作 前后 的 数据 
 
 数据 没有 变化 或 变化 很小 ， 可 排除 此项 操作 ， 否则 就 可 断定 此项 操作 会 引起 资源 耗尽 。 
 
 
 	 对 其它 可疑 的 操作 和 操作 组合 重复 以上 过程 。 
 	 通过 以上 的 步骤 ， 终于 找出 引起 资源 耗尽 的 罪魁祸首 。 分析 相应 部分 的 代码 ， 发现 引起 资 
 
 源 耗尽 原因 有 ： 内存 泄露 ， 画笔 和 画 刷 资源 用 完后 未 释放 等 。 
 
 【 案例 1.10 . 2 】 
 【 正                         文 】 
             某 产品 后台 软件 版本 ， 是 用 C++ 写 的 ， 程序员 在 写 代码 时 ， 经常 在 构造函数 中 申请 一 
 
 块内存 ， 而 不 释放 ， 在 程序 其他 代码 中 也 经常 只管 申请 ， 不管 释放 。 
 例如 : 
   void   WarnSvr : : SaveWarnData ( ) 
 { 
           ...... 
 
 	 	     for ( int   m = 0 ; m < RecordsInBuffer [ EVENT _ ALARM ] ; m ++ ) 
 	 	     { 
 	 	 	 HISTORY _ FILTER _ INDEX *   item = 
                                 new   HISTORY _ FILTER _ INDEX ; 
 	 	 	 item - > Csn = Buffer [ EVENT _ ALARM ] [ m ] . Csn ; 
 	 	 	 
                                                               item - > Position = m   
                                 + ( RecordsInHistoryFile - RecordsInBuffer [ EVENT _ ALARM ] ) ; 
 
 	 	 	 / / If   a   warn   with   a   certain   Csn   is   not   in   EventFilterIndex 
 	 	 	 / / it   is   not   necessary   to   be   added   to     HistoryFilterIndex 
 	 	 	 int   item _ total = EventFilterIndex . GetItemsInContainer ( ) ; 
 	 	 	 BOOL   find _ flag = false ; 
 	 	 	 for ( int   k = 0 ; k < item _ total ; k ++ ) 
 	 	 	   if ( EventFilterIndex [ k ] - > Csn = = item - > Csn ) 
 	 	 	 	   { 
 	 	 	 	   find _ flag = true ; 
 	 	 	 	   break ; 
 	 	 	 	   } 
 	 	 	 if ( find _ flag ) 
 	 	 	     { 
 	 	 	 	 HistoryFilterIndex . Add ( item ) ; 
 	 	 	 	 if ( HistoryFilterIndex . IsFull ( ) ) 
 	 	 	 	     ClearIndexEntry ( ) ; 
 	 	 	   } 
 / / 建议 在 此处 加上 :                                 
 / /                                                           else   
 / /                                                                             delete   item ; 
 } 。 
                 有 的 程序员 认为 ， 后台 运行 的 环境 有 大量 内存 ， 几个 字节 的 浪费 不会 造成 死机 等 
 
 重大事故 。 然而 ， 长时间 累计 起来 ， 必然 会 造成 资源 紧张 而 出现 故障 。 
                   实际上 ， 这种 思想 是 造成 我们 产品 不 稳定 的 原因 之一 。 我们 的 主机 在 网上 能 运行 
 
 几个 月 几年 ， 大家 对 内存 的 分配 释放 较 敏感 ， 而 我们 的 后台 产品 往往 只能 正常 运行 几天 。 
 
 这个 地方 不 注意 也 是 原因 之一 吧 。 
 
 【 案例 1.10 . 3 】 
 【 正                         文 】 
 	 在 进行 代码 审查 过程 中 ， 造成 内存 泄漏 的 代码 比较 多 。 下面 举 几种 常见 的 内存 泄漏 错误 ， 
 
 供 测试人员 在 代码 审查 中 参考 ： 
 	 1 .   函数 有 多个 出口 时 ， 没有 在 每个 出口处 对 动态 申请 的 内存 进行 释放 。 一般 在 异常 处理 
 
 时 容易 出现 这种 错误 。 下面 的 代码段 就是 这样 的 例子 ： 
 ..... 
                 pRecord   =   new   char [ pTable - > GetRecordLength ( ) ] ; 
 	 assert ( pRecord   ! =   NULL ) ; 
 
 	 if   ( pTable - > GoTop ( FALSE )   ! =   DBIERR _ NONE ) 
 	 	 return ;   / /   如果 从 这里 返回 ， pRecord 将 得不到 释放 
           ..... 
                 pTable - > Close ( ) ; 
 	 delete [ ]   pRecord ; 
             } 
 
 
 	 2 .   给 指针 赋值 时 ， 没有 检查 指针 是否 为空 ， 如果 指针 不为 空 ， 那么 指针 原来 指向 的 内存 
 
 将 丢失 。 请 看 如下 代码段 ： 
 .... 
 	 struct   FileInfo   *   pdbffile   =   new   struct   FileInfo ; 
 	 pdbffile - > pfileinfo   =   new   struct   ffblk ; 
 	 pdbffile - > srcname   =   srcRootPath ; 
 	 pdbffile - > desname   =   desRootPath ; 
 	 pdbffile - > prev   =   NULL ; 
 	 pfile   =   pdbffile ; 
 / / 赋值 之前 没有 检查一下 pfile 是否 为空 ， 如果 不为 空 ， 会 造成 pfile 指向 的 内存 丢失 。 
 
 
 	 dbf _ start _ needed   =   FALSE ; 
 	 dbf _ Finish   =   FALSE ; 
 	 flag _ begined   =   TRUE ; 
 	 if ( FALSE   = =   Copy ( TRUE ) ) 
 	 { 
 	 	 dbf _ start _ needed   =   TRUE ; 
 	 	 WarnMsgOut ( " Error   occurs   while   copying   files   in   directory   < dbf > , trying   again 
 
 . " ) ; 
 	 } 
         } 
 
 	 3 .   连续 二次 内存 动态分配 ， 在 第二次 分配 失败 时 ， 忘记 释放 第一次 已经 申请 到 的 内存 。 
 
 
 	 .... 
 	 pMsgDB _ DEV   =   ( PDBDevMsg ) GetBuff (   sizeof (   DBDevMsg   ) ,   __ LINE __ ) ; 
 	 if (   pMsgDB _ DEV   = =   NULL   ) 
 	 	 return ; 
 
 	 pMsgDBApp _ To _ Logic   =   ( LPDBSelfMsg ) GetBuff (   sizeof ( DBSelfMsg ) ,   __ LINE __   ) ; 
 	 if (   pMsgDBApp _ To _ Logic   = =   NULL   ) 
 	 	 return ; / / 此处 返回 造成 pMsgDB _ DEV 指向 的 内存 丢失 
 	 .... 
 	 
 	 4 . 代码 中 缺少 应有 的 条件 分支 处理 ， 导致 程序 未 执行 任何 操作 而 退出 时 ， 也 可能 没有 释放 
 
 应 释放 的 内存 ， 这种 情况 一般 是 缺少 应有 的 else 分支 ， 或 switch 语句 的 default 分支 没有 应 
 
 有 的 处理 。 
 static   void     OncePowerCmdHandle (   struct   HT _ Appmsg     *   msg   ) 
 { 
 	 ...   ... 
         	 pPower _ test _ answer   = ( struct   _ oncepower _ test _ answer   * ) GetBuff ( sizeof ( struc 
 
 t   _ oncepower _ test _ answer ) , __ LINE __ ) ; 
 	 if (   pPower _ test _ answer   = =   NULL _ PTR   ) 	 	 	 	 
 	 	   return ; 
 	 ...   ... 
 	 if   ( TSS _ State [ testpsn ] . state   = =   TEST _ DEV _ BUSY   | | 
 	 	 TSS _ State [ testpsn ] . state   = =   TEST _ DEV _ ERROR   ) 
 	 { ... 
 	 } 
 	 else   if   ( TSS _ State [ testpsn ] . state   = =   TEST _ DEV _ IDLE   ) 
 	 { ... 
   	 } 
 	 / /   缺少   else   分支 ， 可能 造成   pPower _ test _ answer   得不到 释放 
 } 
 
 造成 内存 泄漏 的 情况 很多 ， 以上 是 几种 典型 的 情况 。 
 虽然 内存 泄露 一般 出现 在 异常情况 下 ， 毕竟 给 系统 造成 很大 的 隐患 ， 使 系统 的 健壮性 降低 
 
 。 测试人员 在 作 代码 审查 时 ， 对 上述 几种 情况 要 尤其 注意 。 
 
 【 案例 1.10 . 4 】 
 【 正                         文 】 在 进行 SAR 的 PDU 包 发收 的 测试 过程 中要 同时 考虑 几个 边界值 , 即 发送 
 
 包 大小 范围 [ 0 - Nmax ] , SAR 的 PDU 包 接收 的 最大值 Kmax , MBUF 块 的 大小 M . 在 实测 中 , 将 SAR 的 PD 
 
 U 包 接收 的 最大值 设为 2000 ( Kmax = 2000B ) ,   MBUF 的 块长 设为 512 ( M   =   512B ) , 则 发送 包 大小 的 
 
 正确 分支 的 取值 为 下限 0 , 上限 Nmax = 2000 , 然后 在 0 与 2000 之间 随机 取 若干 值 , 再 考虑 MBUF 的 
 
 块长 , 还 可 增加 M 倍数 的 若干 选值 及其 附近 值 . 以上 是 测试 的 一般 思路 , 但 由于 很 偶然 的 机会 
 
 选择 包长 2000 , 及 Kmax = 2000B , 才 发现 问题 . 原因 如下 : 
 MBUF 块长 512 , 但块 中 实际 存放数据 的 只有 500 ( MBUF 头上 有 2 个 长字 , 尾部 有 1 个长 字 共 12B 只 
 
 用于 块 控制 ) , 而 发送 的 包长 正好 是 500 的 整数倍 4 , 由于 是 整数倍 , 所以 SAR ( BT8230 ) 从 FREE 链 
 
 上 摘成 5 个 MBUF ( 原因 从略 ) , 而 SAR 驱动 只 知道 有 4 个 MBUF , 这样 到 上层 用户 时 , 只 释放 4 个 MBU 
 
 F , 从而 漏掉 1 个 MBUF , 经过 很 短 一段时间 后 , 内存 即 被 耗尽 . ( 此 问题 非常 严重 , 因为 在 实际 运 
 
 用 中 , 是 500 的 整数倍 的 PDU 包 的 概率 较 小 , 但 一旦 出现 就 会 发生 一次 内存 泄漏 , 这样 经过 若干 
 
 天 或 若干 月 的 运行 后会 使 系统 崩溃 ) 
 以前 未 发现 此 问题 的 原因 是因为 原来 使用 的 缓冲 块长 为 2048 , 减去 12B 的 控制 信息 , 实际 存放 
 
 数据 的 长度 为 2036 . 由于 只 考虑 了 2048 这个 值 , 忽略 了 2036 , 所以 在 选取 上 下限 中 的 若干 值时 
 
 , 选取 包 的 长度 是 2036 的 倍数 的 概率 就 非常 小 , 因而 未 发现 该 问题 . 
 由于 测试 中 一般 很难 将 取值 范围 中 的 所有 值 覆盖 全 , 所以 在 选取 上 下限 中 的 若干 取值 时要 格 
 
 外 仔细 , 考虑 的 方面 尽可能 全 , 因为 很 有 可能 其中 某些 值 就是 测试 边界值 . 凡是 涉及 的 数字 尽 
 
 量 选取 , 象该 例中 正确 分支 的 测试 边界 为 0 , 2000 , 512 及其 整数倍 , 500   及其 整数倍 , 12   及其 
 
 整数倍 等值 , 它们 是 必测 的 边界值 , 而 非 可测 可 不测 的 随机 选取 的 所谓 若干 选值 . 
 
 【 案例 1.10 . 5 】 
 【 正                         文 】 
 ABIS . CPP 中 的 函数 rel _ ABIS _ CCB _ conn (   ) 中 ， 在 进行 消息 链表 Msg _ Queue [ ces ] 的 拆链 操作 
 
 时 ， 对于 相应 的 CCB 只 进行 了 一次 拆链 操作 ， 即 只 拆除 了 一个 节点 ， 如果 出现 该 CCB 对应 的 
 
 消息 节点 不止 一个 的 情况 就 会 出现 大量 节点 不能 释放 的 问题 。 
 if (   Msg _ Queue [ ces ] . msghead   ! =   NULL _ PTR   ) / / message   buffer   notempty 
 { 
             / / get   first   message   record 
             pMsgRecord   =   Msg _ Queue [ ces ] . msghead ; 
             / / release   buffer - messages   concerning   with   ccb _ no 
             for (   index   =   0 ;   index   <   MSGBUFFERNUM ;   index ++   ) 
             { 
                   / / 这里 要 对 pMsgRecord 的 值 进行 判断 
                     if (   ( pMsgRecord   ! =   NULL _ PTR )   &&   pMsgRecord - > CCB _ no   = =   
                       ccb _ no   )                   
                   { 
                         / / free   the   message   buffer 
                         if (   pMsgRecord   = =   Msg _ Queue [ ces ] . msghead   ) / / head 
                         Msg _ Queue [ ces ] . msghead   =   pMsgRecord - > pnext ; 
                         else   if (   pMsgRecord   = =   Msg _ Queue [ ces ] . msgtail   ) / / tail 
                         { 
                                         Msg _ Queue [ ces ] . msgtail   =   pPrevMsgRecord ; 
                                         Msg _ Queue [ ces ] . msgtail - > pnext   =   NULL _ PTR ; 
                         } 
                         else / / not   head   and   tail 
                         { 
                                       pPrevMsgRecord - > pnext   =   pMsgRecord - > pnext ; 
                         }   
                         / / put   buffer   back   to   buffer   pool 
                         if (   Msg _ Buffer . empty _ num   = =   0   ) 
                         { 
                                     Msg _ Buffer . linkhead   =   Msg _ Buffer . linktail   =   pMsgRecord ; 
                                     pMsgRecord - > pnext   =   NULL _ PTR ; / / 这里 将 
                                                                                                                                                             
 
 pMsgRecord - > pnext 置 为 空 
                                     Msg _ Buffer . empty _ num ++ ; 
                         } 
                         else 
                         { 
                                     Msg _ Buffer . linktail - > pnext   =   pMsgRecord ; 
                                     pMsgRecord - > pnext   =   NULL _ PTR ; / / 这里 将 
                                                                                                                                                             
 
 pMsgRecord - > pnext 置 为 空 
                                     Msg _ Buffer . linktail   =   pMsgRecord ; 
                                     Msg _ Buffer . empty _ num ++ ; 
                         } 
                   }                 
                   else   if (   pMsgRecord   = =   NULL _ PTR   ) 
                                           break ; / / end   of   if 
                   / / get   next   message   record 
                       pPrevMsgRecord   =   pMsgRecord ; 
                       pMsgRecord   =   pMsgRecord - > pnext ; / / 这时 pMsgRecord 为 
                                                                                                                                               NULL _ PT 
 
 R 将 跳出 for 循环 语句 
             } / / end   of   for 
 } / / end   of   if 
 这里 在 拆除 一个 节点 后 导致 pMsgRecord 为 NULL _ PTR ， 再 进行 判断 时 将 会 跳出 循环 ， 这样 将 
 
 不能 保证 所有 与 同一个 CCB 有关 的 节点均 被 拆除 ， 这时 如果 与 同一个 CCB 对应 的 消息 节点 不 
 
 止 一个 则 这些 消息 节点均 无法 释放 ， 造成 可用 的 节点 数 不断 减少 ， 直接 影响 系统 的 建链 过 
 
 程 ， 给 系统 的 稳定 带来 隐患 。 
 后 与 开发人员 联系 ， 根据 这 段 算法 编写 小 程序验证 了 该 问题 ， 并 提出 了 相应 的 解决方案 ， 
 
 消除 了 该 隐患 。 
 
 【 案例 1.10 . 6 】 
 【 正                         文 】 
               1 、 建立 一个 呼叫 ， 并 保持 通话 。 在 AM 控存 监控 操作界面 中 观察 通话 建立 在 哪一块 
 
 FBI 板上 。 
               2 、 将 有 通话 的 FBI 板 拔出 ， 观察 通话 情况 ， 此时 话音 中断 ， 但 信令 仍然 保持 。 观察 
 
 AM 控存 监控 操作界面 和 E3M 板 2K 网 界面 ， 发现 AM 侧 因为 检测 到 光纤 已断 ， 将 通话 在 CTN 、 E3 
 
 M 板上 占用 的 时隙 置 为 空闲 ， 即 在 AM 控存 监控 操作界面 和 E3M 板 2K 网 界面 观察 不到 时隙 占用 
 
 情况 。 
             3 、 分别 在 30 秒 、 1 分钟 、 3 分钟 时 将 拔出 的 FBI 板 插回 原槽 位 ， 发现 每次 插回 FBI 板后 
 
 话音 立即 恢复 。 
           4 、 观察 BAM 上 的 打印消息 ， 发现 打印 的 各 模块 占用 CTN 板大 HW 上 DM 时隙 的 空闲 个数 比 
 
 较 混乱 。 打印消息 如下 图 所示 ： 
           
           其中 ： 
   
           1 ）   由于 模块 1 、 2 、 3 、 4 各 占用 CTN 板上 两条 大 HW ， 每个 DM 时隙 个数 为 256 （ 即 由 两条 
 
 大 HW 的 两个 DM 组成 ， 由于 与 OPT 相联 的 大 HW 上 有 两个 保留 时隙 ， 因此 此 DM 上 空闲 时隙 个数 为 
 
 ： 254 。 
           2 ）     由于 E3M 板 只 与 一条 大 HW 相联 ， 故 每个 DM 上 空闲 的 时隙 个数 为 ： 128 。 
 
   
 
 
 
 
 
 
 
 
 
 
 
 
 
         本 现象 对应 2 个 问题 ： idle _ count 打印 混乱 ， BM 释放 故障 光路 的 时隙 和 对应 的 CCB 、 无 
 
 线 信道 等 资源 。 
           
 1 、 idle _ count 打印 混乱 是 由于 函数 restore _ one _ hw 中 的 一些 处理不当 造成 的 ， 以前 被 当作 
 
 B型 机 的 历史 遗留问题 没有 重视 ； 
 
 2 、 B2 模块 有 2 条光路 ， 如果 断掉 其中 一条 ， 模块 状态 不会 改变 ， 原 B型 机 程序 对此 不 作 任何 
 
 处理 ， 但 应该 增加 这个 功能 ， 以免 光 路 故障 导致 资源 吊死 。 
 
           解决 方法 ： 
           问题 一 ：   将 函数 restore _ one _ hw 中原 代码 作 如下 改动 ： 
                                                           mod _ dm [ mod ] [ i ] . tail . tsn   =   idle _ dm _ head   +   125 ; 
 	 	                 (   idle _ dm _ head   = =   384   )   ? 
 	 	                         mod _ dm [ mod ] [ i ] . idle _ count   + =   TS _ PER _ DM   -   1 : 
 	 	                         mod _ dm [ mod ] [ i ] . idle _ count   + =   TS _ PER _ DM   -   1 ; 
 
 	 	 改为 ： 
 	 	 	 if   (   idle _ dm _ head   ! =   384   ) 
 	 	 	 { 
 	 	                                           mod _ dm [ mod ] [ i ] . tail . tsn   =   idle _ dm _ head   +   127 ; 
 	 	 	                       mod _ dm [ mod ] [ i ] . idle _ count   + =   TS _ PER _ DM ; 
 	 	 	 } 
   
 	 	 	   else 
 	 	 	 { 
 	 	 	                       mod _ dm [ mod ] [ i ] . tail . tsn   =   idle _ dm _ head   +   126 ; 
 	 	 	                       mod _ dm [ mod ] [ i ] . idle _ count   + =   TS _ PER _ DM   -   1 ; 
 	 	 	 } 
             问题 二 分析 如下 ：   
                       目前 的 模块 状态 是 由 IPATH 调用 DBMS 模块 的 边 检查 实现 的 ， 只要 存在 一条 可用 
 
 的 光路 ， 即 认为 相邻 模块 为 正常 ， 对于 具体 的 OPT 板上 的 时隙 状态 的 维护 没有 与 呼叫 控制 的 
 
 接口 。 具体 的 OPT 板 状态 功能 的 检测 是 由 IPATH 完成 的 ， 在 BM 侧 没有 专门 维护 OPT 和 MC2 板 的 
 
 模块 ， 将 转交 OS 组 处理 。 
 
               总结 ： 
                   在 拔出 FBC 板后 ， 通话 话音 被 中断 ， AM / CM 侧 已 将 与 被 拔出 的 FBC     板 相关 的 资源 
 
 全部 置 为 不可 用 ， 此时 BM 侧 主机 程序 也 应该 与 AM / CM 侧 一致 ， 释放 掉 所 占用 的 资源 ， 并 将 原 
 
 通话 的 信令 连接 断开 。 这 可能 是 由于 不同 模块 的 开发人员 缺少 相互间 了解 而 造成 的 ， 即 AM 
 
 / CM 侧 与 BM 侧 开发人员 交流 不够 。 作为 测试人员 对 类似 两个 或 多个 模块 相关 的 部分 应该 充分 
 
 进行 测试 ， 不要 想当然 ， 往往 是 看起来 不 可能 出 问题 的 地方 也 容易 测出 问题 。 
 
 【 案例 1.10 . 7 】 
 	 在 进行 有关 排队 指示 的 系统 测试 中 ， 先 闭塞 掉 基站 的 所有 业务 信道 TCH ， 进行 呼叫 ， 再直 
 
 接 挂机 或 超时 释放 ， 发现 TC 存在 中继 资源 吊死 的 问题 。       
 	 由于 此 问题 重现 ， 后经 定位 分析 ， 发现 是 ccb 超时 后 收到 AIR 发来 的 clear   cmd ， 进入   rel 
 
 _ one _ bm _ res (   ) 时 ， 由于 ccb 所 登记 的 CIC 还 放在 pre _ occupied _ res ， 并 没有 放入 occuped _ 
 
 res ， 而 rel _ one _ bm _ res ( ) 只 对 存入 occuped _ res 的 CIC 进行 判断 ， 并 向 AIE 发 UNBOOKCIC ， 而 
 
 没有 对 存入 pre _ occupied _ res 的 CIC 进行 判断 ， 并 UNBOOK 掉 ， 导致 TC 的 中继 资源 吊死 。 应 在 
 
 超时 函数 或 释放 函数 中 对 pre _ occupied _ res 的 CIC 进行 处理 。 
 在 此 过程 中 ， CIC 资源 还 存放 在 老 CCB 的 pre _ occupied _ res 中 ， 在 超时 函数 或 释放 函数 中均 
 
 未 对 pre _ occupied _ res 中 的 CIC 进行 处理 （ 即 向 AIE   UNBOOK ） ， 导致 TC 中继 资源 吊死 。 
 	 在 超时 函数 RR _ time _ out ( ) 中 timer _ name 为 TN _ WAIT _ ASS _ READY 时 ， 和 释放 函数 rel _ one _ b 
 
 am _ res ( ) 中 增加 对 CCB 的 pre _ occupied _ res 中 的 CIC 的 判断 和 释放 处理 。 
               	 在 使用 资源 同时 ， 就要 周密 地 考虑 好 资源 的 释放 问题 ， 只有 这样 ， 才能 使 我们 的 
 
 系统 不断 地 稳定下来 。 
   	 资源 的 释放 对于 我们 的 交换机 来说 是 至关重要 的 ， 一点点 的 疏忽 都 可能 最终 使 我们 的 交 
 
 换机 因为 无 资源 使用 而 死 掉 ， 要 知道 ， “ 千里 长堤 ， 毁于蚁穴 ” 。 
 
 11 、 防止 资源 的 重复 释放 
 【 案例 1.11 . 1 】 
 【 正                         文 】 
               当 进行 大 话务量 呼叫 时 ， 在 统计 代码 中 出现 AIE 收到 UNBOOK   CIC 消息 时 ， 发现 自身 
 
 电路状态 为 空闲 ， 出现 一个 断言 。 这 说明 AIE 电路 电路 被误 释放 了 。 
 	 这个 问题 出现 的 原因 有 以下 几种 ： 
 	 1 .   RR 可能 发错 了 电路 号 ， 导致 AIE 状态 错误 。 
 	 2 .   AIE 可能 发起 资源 核查 ， 失败 后 将 本 控制 表项 释放 了 。 
 	 3 .   RR 可能 发起 了 重复 释放 操作 ， 导致 AIE 的 某个 表项 连续 收到 两个 UNBOOK 消息 。 
 	 分析 完 了 可能 的 情况 ， 就要 一一 分析 定位 。 
 	 在 可能 原因 一 发生 的 情况 下 ， RR 发来 的 UNBOOK 消息 所带 的 AIR 连接号 和 模块号 会 错误 ， 导 
 
 致 我们 会 出现 断言 。 而 在 测试数据 结果 文件 中 ， 没有 出现 这个 断言 ， 因此 可能 原因 一 不成 
 
 立 。 
 	 在 可能 原因 二 发生 的 情况 下 ， AIE 收到 资源 核查 失败 消息 的 数目 应该 不是 零 。 但是 实际 情 
 
 况下 统计 结果 中 收到 资源 核查 失败 消息 的 个数 为 零 ， 说明 情况 二 也 不 成立 。 
 	 由 上 分析 ， 这个 问题 只 可能 是 由于 RR 重复 释放 造成 的 。 但是 为何 会 发生 重复 释放 ， 这 需要 
 
 进行 进一步 分析 。 
 	 从 呼叫 的 正常 流程 来看 ， 是 不会 产生 重复 释放 的 ， 因此 我们 怀疑 该 问题 与 异常 流程 有关 。 
 
 从 统计 代码 中 查找 异常 流程 ， 发现 该次 统计 中 BSC 内 切换 流程 多次 出现 问题 ， 具体 原因 是 由 
 
 于 切换 过程 中 在 目标 小区 申请 不到 信道 ， 产生 切换 失败 造成 的 。 因此 集中 研究 这个 流程 ， 
 
 发现 存在 问题 如下 ： 
 	 当原 小区 向 目标 小区 发送 内部 切换 请求 消息 时 ， 带来 了 AIR 和 AIE 的 各项 信息 ， 而 目标 小区 
 
 收到 这些 信息 后 就 将 之 保存 在 自身 的 占用 资源 中 。 如果 目标 侧 申请 信道 失败 ， 就会 向源侧 
 
 发 内部 切换 拒绝 消息 ， 而后 产生 本地 释放 。 由于 在 释放 前 目标 侧 RR 没有 将 占用 资源 中 的 AI 
 
 R 和 AIE 信息 清除 ， 因此 导致 重复 释放 时 对 AIR 和 AIE 发起 了 释放 操作 。 由于 AIR 释放 时有 保护 
 
 机制 ， 所以 不会 产生 问题 ， 而 AIE 没有 保护 机制 ， 新 CCB 就 将 AIE 电路 释放 掉 了 。 而后 当老 C 
 
 CB 在 通话 结束 后 发起 释放 时 ， 就 产生 了 重复 释放 。 
 	 从 上面 分析 可以 看出 ， 这个 问题 是 由于 RR 释放 流程 的 错误 造成 的 ， 因此 ， 我们 要 对此 加以 
 
 修改 ， 在 新 CCB 释放 前 将 AIR 和 AIE 信息 从 预占 资源 中 清除 。 
                 RR 的 释放 是 一个 非常复杂 的 过程 ， 如何 正确 的 整理 资源 ， 确保 资源 的 合理 释放 ， 
 
 这是 摆在 我们 面前 的 一个 艰巨 的 问题 ， 我们 要 仔细分析 各种 可能 发生 的 情况 ， 正确 释放 各 
 
 种 资源 ， 即 不会 吊死 资源 ， 也 不会 产生 重复 释放 。 
 
 12 、 公共资源 的 互斥性 和 竞用 性 
 【 案例 1.12 . 1 】 
 【 正                         文 】 
 	 试验 环境 ： CPX8216   CPCI   机架 、 vxWorks 操作系统 、 Tornado1.0 . 1 调试 环境 
 	 测试用例 ： 测试 板 间通信 性能 。 从 接口板 A 向 接口板 B 循环 发送 消息 ， 通过 超级终端 观察 消 
 
 息 的 收发 情况 。 
 	 测试 结果 ： 每 发送 一定 数量 的 消息 帧 后 ， 会 出现 发送 地址 出错 现象 。 
 	 原因 分析 ： 接收 板 回送 缓冲区 指针 给 发送 板 ， 是 采用 memcpy 单字节 拷贝 的 方式 。 若 发送 速 
 
 度快 于 接收 速度 ， 两板 竞用 发送 板 系统总线 访问 缓冲区 指针 所在 的 共享内存 ， 导致 数据 访 
 
 问 冲突 。 memcpy 过程 被 打断 ， 即 出现 发送 板读 发送 地址 出错 现象 。 
 	 采用 四 字节 拷贝 函数 bcopyLongs 传送 发送缓冲区 指针 ， 问题 解决 。 
 	 共享内存 的 访问 设计 ， 除了 考虑 互斥 外 ， 还有 总线 竞用 问题 。 
 
 【 案例 1.12 . 2 】 
 【 正                         文 】 
 问题 描述 ： 
                 在 进行 主 BCCH 载频 互助 新 功能 开发 的 并行 联调 测试 的 过程 中 ， 发现 了 以下 的 问题 
 
 ： 在 数管 台 设置 “ TRX 倒换 是否 允许 ” 为 “ 是 ” ， 进行 设定 整表后 ， 关闭 基站 其中 配有 4 个 
 
 TRX 的 小区 的 主 BCCH 所在 的 TRX 电源 ， 发现 对应 小区 重新 初始化 并 成功 ， 也 就是 载频 互助 成 
 
 功 。 这个 时候 从 后台 对 该 小区 所在 的 站点 进行 4 级 复位 ， 同时 重新 打开 之前 关闭 的 该 小区 的 
 
 原配 主 BCCH 所在 TRX 的 电源 ， 发现 对应 小区 初始化 失败 。 
 问题 定位 ： 
                   在 问题 定位 开始 ， 先是 查看 了 载频 互助 相关 代码 在 站点 初始化 流程 中 的 处理 。 B 
 
 TSM 程序 初始化 过程 中 ， 先是 判断 这 一次 初始化 之前 是否 发生 过 载频 互助 ， 若 发生 过 ， 再判 
 
 断 原配 主 BCCH （ 即 数据库 中 实际 配置 的 主 BCCH 所在 的 TRX ） 是否 已经 恢复 （ 即能 正常 建立 T 
 
 EI ， 能 正常 设置 该 TRX 对应 的 RC 属性 ， 总之 能 正常 开工 ） 。 若 载频 互助 发生 过 ， 且 原配 主 B 
 
 CCH 所在 的 TRX （ CoTRXGroupForBts [ BtsNo ] . MainTRX ） 已经 恢复 ， 即 把 之前 进行 互助 的 TRX 
 
   （ CoTRXGroupForBts [ BtsNo ] . AidTRX ） 的 数据 和 原配 的 主 BCCH 所在 TRX 的 数据交换 回来 ， 
 
 并 重新 进行 初始化 。 表面 上 看 原理 应该 没有 什么 逻辑 错误 ， 怎么 会 出现 初始化 不 成功 呢 ？ 
 
 
 我们 对 程序 中 的 每 一个 可能 导致 该 问题 的 变量 加 打印 调试程序 ， 然后 重现 该 问题 ， 终于 在 
 
 打印 出来 的 信息 中 发现 在 载频 互助 发生 后 其 互助 的 主 BCCH 所在 的 TRX 与 实际 数据 配置 主 BCC 
 
 H 所在 的 TRX 为 同一 TRX ， 这有 问题 ， 因为 载频 互助 的 实质 就是 实际 数据 配置 主 BCCH 所在 的 T 
 
 RX 不能 正常 开工 而 借用 其他 TRX 作为 主 BCCH 。 于是 我们 根据 此 线索 查询 了 所有 BTSM 的 程序 ， 
 
 没有 发现 问题 的 根源 。 于是 我们 查 了 最近 合进 版本 的 相关 模块 的 程序 ， 终于 找出 了 问题 的 
 
 根源 所在 。 
 在 载频 互助 程序 中以 全局变量 ptrBTS _ CONFIG _ MAP [ BtsNo ] . TRX _ no _ BCCH _ in 表示 当前 实际 运 
 
 行 的 主 BCCH 所在 的 TRX 号 ， 是 随时 变化 的 ； 以 CoTRXGroupForBts [ BtsNo ] . MainTRX 表示 原配 
 
 的 主 BCCH 所在 的 TRX 号 ， 是 固定 的 。 两者 在 系统 开工 的 系统 开工 的 接口函数 FetchOneSiteC 
 
 onfig （   ） 中赋 了 相同 的 值 ： 该 函数 的 409 行有 赋值 语句 CoTRXGroupForBts [ BTS _ no _ temp ] 
 
 . MainTRX   =   ptrBTS _ CONFIG _ MAP [ BTS _ no _ temp ] . TRX _ no _ BCCH _ in 。 以前 函数 FetchOneSite 
 
 Config （ ） 只是 在 系统 开工 时才 调用 过 一次 ， 故 CoTRXGroupForBts [ BTS _ no _ temp ] . MainTR 
 
 X   在 系统 开工 以后 是 不变 的 ， 但是 在 DBMI 同步 开发 的 整改 中 ， 作 了 如下 处理 ： 在 每 一 次数 
 
 据 动态 设定 后 ， 先 判断 站点 下 有没有 发生 过 载频 互助 ， 若 发生 过则 试图 先 把 目前 进行 互助 
 
 的 TRX 的 数据 与 实际 数据 配置 成主 BCCH 的 TRX 的 数据 倒换 回来 ， 然后 进行 站点 初始化 。 问题 
 
 就 出现 在 这 ， 在 DBMI 中 认为 DB 中 原配 的 主 BCCH 的 TRX 是 ptrBTS _ CONFIG _ MAP [ BTS _ no _ temp ] . 
 
 TRX _ no _ BCCH _ in ， 而且 每次 进行 站点 初始化 时 都 调用函数 FetchOneSiteConfig （ ） ， 这样 
 
 将 导致 CoTRXGroupForBts [ BTS _ no _ temp ] . MainTRX 的 值 与 DB 中 实际 原配 主 BCCH 所在 TRX 不一 
 
 致 ， 从而 导致 主 BCCH 的 相关 数据 倒换 是 出现 错误 ， 最终 导致 相应 小区 初始化 不 成功 。         
 
                                                           
 收获 及 反思 ： 这个 问题 的 出现 是因为 主机 程序 两个 功能模块 DBMI 与 BTSM 之间 的 开发 缺少 相 
 
 互 沟通 引起 ， 如果 在 开发 之前 两个 模块 的 的 开发人员 先 约定 好 各个 全局变量 的 用途 ， 如果 
 
 DBMI 与 BTSM 两个 功能模块 都 认为 CoTRXGroupForBts [ BTS _ no _ temp ] . MainTRX 是 实际 数据 的 原 
 
 来 的 主 BCCH 所在 的 TRX 号 ， 那么 就 不会 出现 以上 问题 。 现在 BSC 主机 程序 的 各个 功能模块 都 
 
 同时 合进 了 许多 代码 ， 各个 功能模块 之间 的 联系 与 冲突 肯定 会 存在 ， 这 就 需要 开发人员 在 
 
 开发 设计方案 时 就 相互 沟通 ， 否则 以上 由于 功能模块 间 的 的 冲突 引起 的 问题 肯定 会 存在 ， 
 
 而且 可能 不 那么 明显 的 暴露 了 出来 。 我们 的 产品 埋伏 的 炸弹 的 机会 就 越 多 。 
 
   
 二 、 接口类 代码 问题 
 1 、 对 函数参数 进行 有效性 检查 
 【 案例 2.1 . 1 】 
 【 案例 描述 】 
           某 交换 类产品 BAM 后台 管理系统 使用 了 注册表 存储 后台 系统 数据 自动 备份 时间 ； 在 对 
 
 数据 自动 备份 进行 系统 测试 时 考虑 到 注册表 中 数值 的 任意性 ， 很 有 可能 被 测系统 没有 对注 
 
 册表中 存储 的 值作 相应 的 合法性 检测 ， 从而 有 可能 对系统 产生 不良影响 。 
 
 【 处理过程 】 
 通过审查 源程序 及 实际 验证 ， 发现 果然 存在 问题 。 BAM 有关 数据 自动 备份 程序 程序 在 得到 该 
 
 项值 后 只 做 了 简单 处理 ， 没有 对 时间 进行 合法性 验证 。 若 自动 备份 操作 发生 在 前后 台 通讯 
 
 的 高峰期 或者 是 在 设置 数据 需要 对 数据库 进行 操作 时 ， 对系统 可能 会 产生 重大 影响 。 
 
 【 结     论 】 
 系统 使用 注册表 中 的 数据 同样 要 进行 各种 情况 下 的 测试 ， 包括 合法 的 和 不 合法 的 数据 设置 
 
 。 
 
 【 思考 与 启示 】 
 系统 的 数据 输入 有 多种 渠道 ， 不仅 包括 人机 命令 、 系统 INI 文件 ， 还 包括 注册表 等 其它 途径 
 
 ； 在 测试 时 对 各种 情况 都 要 进行 全方位 的 测试 ， 从而 保证系统 的 可靠性 。 
 
 【 案例 2.1 . 2 】 
 【 案例 描述 】 
 	 设计 规定 07 的 TSS 板 是 不 支持 数字 用户 内 ， 外线 强测 的 ， 在 对 数字 用户 内 ， 外线 测试 正常 
 
 后 ， 有意 强测 一 正在 通话 的 数字 用户 ， 却 发现 返回 报告 ： 
 用户 外线 测试 
 - - - - - - - - - - - - 
                                             测试 时间   =   1999 - 06 - 03   16 : 48 : 06 
                                                 号 首集   =   0 
                                             用户 号码   =   6540136 
                                       BAM 测试状态   =   正常 
                                     主机 测试状态   =   正常 
                                                     AVAG   =   0.08       
                                                     AVBG   =   0.29       
                                                     AVAB   =   - 0.21     
                                                     DVAG   =   0.62       
                                                     DVBG   =   0.62       
                                                     DVAB   =   0.00       
                                                       RAG   =   > 10M 
                                                       RBG   =   > 10M 
                                                       RAB   =   > 10M 
                                                         RL   =   > 10M 
                                                       CAG   =   0.001   
                                                       CBG   =   0.001   
                                                       CAB   =   0.001   
                                                     结论   =   断线 
 结论 断线 肯定 是 错误 的 ， 测试 期间 查询 TSS 状态 ， 显示 TSS 空闲 ， 可见 主机 返回 的 报告 是 错 
 
 误 的 。 
 
 【 处理过程 】 
 	 修改 命令 ADD   RTSTI 对应 的 存储 过程 ， 问题 解决 。 
 
 【 结     论 】 
 	 用户 外线 测试主机 没有 判 用户 是否 为 数字 用户 。 
 
 【 思考 与 启示 】 
 	 测试 一项 功能 ， 既 要 测试 系统 提供 的 功能 要 满足要求 ， 系统 没有 提供 的 功能 看 是否 误 执行 
 
 了 ， 导致 错误 的 结论 。 
 
 【 案例 2.1 . 3 】 
 【 正                         文 】 
 	 一般 开发人员 认为 函数 的 参数 很 简单 ， 但 在 实际 设计 和 调用函数 时 ， 很 容易 犯 一些 参数 方 
 
 面 的 错误 。 下面 就 一些 例子 进行 一些 分析 ， 希望 能 引起 大家 的 重视 。 
 	 1 、 函数 设计 中 ， 使用 函数 内 局部变量 保存 下次 函数 重新 调用 时 需要 的 保留值 。 
 void   SlaverDownLoadProc (   WORD   wMsgLength   ,   void   * pTempMsgAddr   ) 
 { 
 	 void   * pTempTargetAddr   ; 
 
 	 SSLAVERLOADMSG   * pSTempSlaverLoadMsg   =   (   SSLAVERLOADMSG   *   ) pTempMsgAddr ; 	 
 	 
 	 if   (   COMMON _ BOARD _ LOAD _ PROGRAM   = =   pSTempSlaverLoadMsg - > m _ ucCmd   ) 
 	 	 pTempTargetAddr   =   (   void   *   ) SDRAM _ LOAD _ PROG _ START _ ADDR   ; 
 # ifndef   MMX     / *   MMX 板 的 数据 不用 加载 ， 用 备份 方式 * / 
 	 else   if   (   COMMON _ BOARD _ LOAD _ FPGA   = =   pSTempSlaverLoadMsg - > m _ ucCmd   ) 
 	 	 pTempTargetAddr   =   (   void   *   ) SDRAM _ FPGA _ START _ ADDR   ; 
                             ... 
                         
                         case   BEGIN _ LOAD   : 
               	 if   (     (   LOAD _ MIDDLE _ FRAME   = =   pSTempSlaverLoadMsg - > m _ ucLoadCmd   )   
 	         && (   (   dwRecFrameNum   %   0xFF   )   = =   pSTempSlaverLoadMsg - > m _ ucOrderNo   )       
 	       ) 
 	 { 
 	 / *   序号 和 帧 的 命令字 都 是 合法 的 ， 保存 BUFFER   * / 
 	 	 memcpy (   (   BYTE   *   ) pTempTargetAddr   ,   (   BYTE   *   ) pSTempSlaverLoadMsg   +   5   ,   wMsg 
 
 Length   -   5   )   ; 
 	 / *   5   =   m _ ucBoardType   +   m _ ucCmd   +   m _ ucSerialNo   +   m _ ucLoadCmd   +   m _ ucOrderNo   * / 
 
 
 	 	 dwRecFrameNum   ++   ; 
                                 ... 
                 
 	 这里 每 收到 一帧 都 要 调用 此 函数 ， 而 每次 进入 时 ， 函数 将 pTempTargetAddr 赋值 为 两个 固 
 
 定值 中 的 一个 ， 导致 收到 的 新 帧 将 上 一次 的 帧 数据 覆盖 。 显然 ， 函数 将 本应 作为 全局变量 
 
 的 参数 pTempTargetAddr 错误 地 定义 为 局部变量 。 
 	 2 、 当 函数 的 输入 参数 较 多 ， 并且 互相 之间 有 联系 时 ， 是 较易 出错 的 地方 。 
 	 在 测试 串口 任务 时 ， 我们 发现 一个 错误 ： 当 加入 新 用户 时 ， 当 用户名 输入 到 四十一个 字符 
 
 时 ， 程序 死 掉 。 经过 调试 跟踪 ， 发现 是 在 input 函数 中 调用 GetString ， 但是 在 对 第二个 参 
 
 数 赋值 时 ， 没有 搞清楚 参数 之间 的 关系 。 第一个 参数 （ 传入 的 指针 ） 指向 一 长度 为 40 字符 
 
 的 字符串 ， 而 在 对 第二个 参数 时 ， 错误 地 将 字符串 长度 设置 为 41 。 导致 串口 接收 第 41 个 字 
 
 符时 ， 程序 越界 操作 ， 导致 死机 。 下面 是 函数 GetString 的 声明 ： 
 signed   long   GetString   
 (   
         char   *   szString ,                   / *   OUT :   字符串 指针   * / 
         WORD   wSize                         / *   IN :   指定 的 字符串 长度   * / 
 ) 
 1 
 	 当然 有关 函数参数 的 错误 不止 这些 ， 例如 未 在 模块接口 函数 内部 检验 传入 参数 的 合法性 、 
 
 指针 参数 的 有效性 、 参数 未 赋值 就 使用 、 参数 类型 不 匹配 或 考虑不周 导致 上溢 下溢 等 。 这 
 
 些 都 是 编程 者 容易 出错 的 地方 ， 亦 是 我们 大家 在 走读 代码 时 ， 需要 特别 注意 的 地方 。 
 
 【 案例 2.1 . 4 】 
 【 正                         文 】 
 	 在 交换机 的 V5 协议 测试 中 ， 有 一个 相当 常用 又 相当 简单 的 测试项目 ， “ 交换机 对 某个 V5 接 
 
 口 发起 主备 倒换 命令 ” 。 这 在 所有 的 V5 测试 中 都 会 很 顺利 地 通过 的 项目 ， 在 以前 这个 项目 
 
 也 测试 过 许多次 ， 也 从来 没有 遇到 过 异常情况 。 
 	 可是 在 一次 测试 中 却 遇到 麻烦 ， 在 交换机 侧 输入 了 参数 “ 模块号 ” 、 “ V5 接口号 ” 、 “ 逻 
 
 辑 C 通道 ID ” 之后 ， 发起 主备 链路 倒换 的 命令 ， 操作 的 结果 居然 是 “ 无效 的 V5 端口 ” 。 
 	 这种 提示 令人 感到 很 诧异 ， 因为 从 AN 侧 能够 正常 发起 主备 链路 倒换 ， 从 LE 侧 也 能 正常 发起 
 
 该 V5 端口 的 指定 链路 倒换 ， 而且 系统 也 完全 正常 ， 可见 数据 配置 并 没有 错误 。 排除 了 人为 
 
 的 错误 之后 ， 我 把 重点 放到 了 这 三个 输入 参数 上 ： “ 模块号 ” ， “ V5 接口号 ” 均 是非 常常 
 
 规的 数值 ， 应该 没有 问题 ； “ 逻辑 C 通道 ID ” 数值 比较 大 ， 但是 仍然 在 协议 规定 的 65535 之 
 
 内 ， 应该 为 有效值 。 想到 常规 配置 数据 时 “ 逻辑 C 通道 ID ” 值 一直 配 得 比较 小 ， 或许 问题 就 
 
 出 在 此 。 
 	 于是 把 “ 逻辑 C 通道 ID ” 值 改小 ， 再作 同样 的 操作 ， 操作 成功 。 到 此 很 显然 是 这个 参数 的 
 
 有效值 范围 定义 有误 ， 再 细细 检查 ， 发现 它 只 在 单字节 范围 内 有效 ， 必然 是 该 参数 定义 的 
 
 类型 有误 。 原因 是 ： 在 函数 OAM _ Swap _ Communication _ Link （ _ UC   v5 _ interface ， _ UC   log 
 
 ic _ c _ id ） 里 将 逻辑 C 通道 定义 为 字符 型 导致 ， 改为 _ US 型 即 解决 。 
 	 推而广之 ， 在 终端 的 功能测试 中 ， 对 输入 参数值 的 测试 ， 应该 尽量 覆盖 所有 的 有效值 。 在 
 
 正常 情况 下 ， 如果 输入 值 在 为 有效值 ， 则 应该 得出 正确 的 结果 ； 如果 输入 值为 非法 值 ， 则 
 
 系统 应该 给出 错误 提示 ， 并且 不予 执行 。   对于 参数值 有效性 的 判断 ， 特别 应该 注意 一些 特 
 
 殊值 和 临界值 ， 比如 在 字节 和 双 字节 处 等等 。 
 
 【 案例 2.1 . 5 】 
 现象 与 分析 ： 
                 在 回归 “ 载频 配置 表及 跳频 数据表 中有 零 频点 或 重复 频点 时 ， MA 编码 不 正确 ” 问 
 
 题 单时 。 发现 当 载频 配置 表及 跳频 数据表 中有 重复 频点 或 零 频点 时 ， 带 跳频 的 呼叫 不 成功 
 
 。 
                   这时 首先 考虑 系统 消息 发 的 是否 正确 ， 观察 系统 消息 一 ， 发现 所带 的 CA 表 没有 错 
 
 误 ， 已经 过滤 掉 了 重复 频点 和 零 频点 。 
                   在 考虑 指配 命令 所带 的 MA 值 是否 正确 ， 结果 发现 MA 编码 也 是 正确 的 ， 也 已经 过滤 
 
 掉 重复 频点 和 零 频点 。         
                   经过 以上 初步 分析 以后 ， 开始 怀疑 给 基站 下 配置 时 是否 也 正确 过滤 了 无效 频点 。 
 
 然后 查阅 代码 ， 发现 果然   BTSM 在 对 基站 初始化 设置 载频 属性 及 设置 信道 属性 时 ， 没有 对载 
 
 频 配置 表及 跳频 数据表 中频 点 的 有效性 做 检查 ， 以致于 表中 出现 非法 频点 时 跳频 呼叫 不成 
 
 功 。 
     
     回顾 与 反思 ： 
                     这个 问题 的 发现 并 没有 用 什么 特殊 的 分析方法 ， 只不过 是 一般 的 “ 排除法 ” ， 
 
 而且 这个 问题 也 不是 隐藏 的 非常 之深 ， 但是 我 觉得 这个 问题 的 发现 暴露 了 我们 在 开发 过程 
 
 中 的 一个 问题 。 那 就是 ： 如何 实现 各个 模块 之间 的 有效 沟通 ， 避免 因为 某一 模块 的 修改 而 
 
 引起 其他 模块 的 连锁 反映 。 
                 本来 RR 和 BTSM 都 没有 考虑 重复 频点 和 零 频点 的 情况 ， 大家 都 寄托 与 数据 配置 的 正 
 
 确 ， 却 也 相安无事 。 RR 首先 增加 了 对 非法 频点 的 过滤 ， 本来 是 件 好事 ， 使 我们 的 系统 变 的 
 
 更加 坚强 ， 但是 BTSM 并不知道 这一 变化 ， 于是 在 错误 数据 面前 束手无策 ， 反而 起到 了 相反 
 
 的 效果 。 
                 公司 常说 “ 下 一道 工序 是 上 一道 工序 的 上帝 ” ， 是不是 可以 引申为 “ 其他 相关 模 
 
 块 是 本 模块 的 上帝 ” 。 试想 如果 各个 模块 多 想想 自己 的 改动 是否 给 别人 带来 不良影响 ， 多 
 
 及时 了解 一下 其他 模块 的 最新进展 。 那么 此类 问题 将 不再 会 发生 。 
 
 【 案例 2.1 . 6 】 
 【 正                         文 】 
 现象 与 分析 ： 
                   在 动态数据 配置 测试 增加 小区 时 ， 发现 小区 不能 正常 初始化 。 观察 ABIS _ BTSM 接 
 
 口 跟踪 窗口 ， 没有 关于 初始化 流程 的 相关 消息 。 经过 分析 发现 是 调用函数 。 
       BTSM _ make _ send _ site _ config ( _ UC   site _ no   ,   _ UC   ObjectClass   ,   _ US   BTS _ no   , _ UC   
 
 TRX _ no   ,   _ UC   OperMode ) 
 { 
           … … … 
         / / 判断 合法性 
         if   ( ( site _ no   > =   MAX _ SITE _ NUM ) 
                 | |   ( BTS _ no   > =   MAX _ BTS _ NUM ) 
                 | |   ( TRX _ no   > =   MAX _ TRX _ A _ BTS ) ) 
         { 
                   ASSERT ( FALSE ) ; 
                   return   ( FALSE ) ; 
         } 
 　 　 … … … 
 } 
 由于 进行 小区 级 的 操作 调用 该 函数 时 ， TRX _ NO 以 0xFF 带入 ， 则 在 函数 合法性检查 时 就 会 返 
 
 回 。 从而 引发 该 错误 。 
 
 回顾 与 反思 ： 
         这是 一个 比较 普通 的 错误 ， 但是 回顾 它 产生 和 解决 的 过程 ， 觉得很有 启发 ， 也 引起 了 
 
 我 对 编程 规范 的 一些 思考 。 
 
 	 可以 说 该 错误 的 引起 是 与 编程 规范 有关 , 本来 函数   BTSM _ make _ send _ site _ config ( ) 没有 对 
 
   BTS _ no 和 TRX _ no   的 合法性 判断 ， 在 代码 审查 时 ， 我们 考虑 到 这 不 符合 编程 规范 中 的 “ 检 
 
 查 所有 参数 输入 的 有效性 ” 这 一条 ， 于是 提出 请 开发人员 增加 对 参数 的 有效性 检查 。 
                   但是 我们 和 开发人员 都 忽略 的 一个 问题 ， 那 就是 ， 该 函数 被 不同 级别 的 对象 调用 
 
 ， 当 进行 小区 级 操作 时 ， TRX _ NO 以 0xFF 带入 ， 则 在 函数 合法性检查 时 就 会 返回 ， 引起 上述 
 
 错误 。 
         让 我们 再 回头 看看 这个 函数 ， 发现 依然 不 符合 编程 规范 ， 至少 违反 了 “ 不要 设计 多用 
 
 途 面面俱到 的 函数 ” 这 一条 。 
         查看 我们 的 代码 ， 类似 的 问题 还有 不少 ， 而且 诸如 ： 函数 入口 参数 不 加 有效性 检查 、 
 
 函数 返回值 不 加 处理 等 问题 也 可以 找到 。 这些 问题 就象 一颗颗 隐型 炸弹 ， 在 稍微 不 注意 时 
 
 就 会 带来 严重后果 。 
         正如 前 文 所述 ， 测试 和 开发人员 都 会 因为 “ 代码 熟悉 程度 ” 、 “ 代码 编制 时间 太久 有 
 
 所 遗忘 ” 等 诸如此类 的 原因 而 忽略 一些 问题 。 这时 ， 良好 的 程序 风格 和 编程 规范 就 会 成为 
 
 一把 强有力 的 保护伞 。 试想 如果 本文 所 提到 的 函数 从 设计 到 开发 都 严格 按照 规范 来 进行 ， 
 
 那么 这个 问题 就 没有 产生 的 土壤 ， 如果 我们 的 每 一段 代码 的 编写 都 严格遵守 规范 ， 那么 我 
 
 们 的 系统 将 变 的 有 多么 坚不可摧 。 
 
 2 、 注意 多 出口 函数 的 处理 
 【 案例 2.2 . 1 】 
 摘                         要 ： 如果 函数 存在 多个 出口 ， 应 注意 函数 对 各个 出口 的 处理 。 
               问题 描述 ： 根据 函数 功能 的 需求 ， 被测 函数 在 函数 体 开始 时 保存 了 当前 系统 任务 模 
 
 式 ， 并 设置 新 的 任务 模式 为 不可 抢占 模式 ， 在 函数 返回 时 应该 恢复 任务 的 旧 模式 ， 否则 会 
 
 影响 整个 系统 功能 的 实现 。 可是 问题 就 出 在 这里 。 由于 函数 有 复杂 的 分支 结构 ， 有 多个 出 
 
 口 ， 有 的 出口 对 任务 模式 进行 了 恢复 ， 有 的 出口 没有 恢复 ， 这样 就 可能 导致 函数 返回 后系 
 
 统 任务 模式 被 改变 的 问题 。 
                 问题 分析 ： 此 问题 出现 的 原因 在于 函数 有 多个 出口 ， 而 程序员 往往 注重 各个 分支 
 
 功能 的 实现 的 细节 ， 而 忽视 了 或者 是 忘记 了 在 函数 出口 应 做 的 收尾 工作 。 这 就 象 打 一场 战 
 
 争 一样 ， 战争 胜利 了 ， 还要 打扫战场 ， 开 总结 大会 ， 否则 就会象 李自成 一样 ， 仗 打 完 了 就 
 
 开始 享受 了 ， 最后 前功尽弃 。 毛主席 说得好 ： “ 宜将 剩勇 追 穷寇 ， 不可 沽名 学 霸王 ” 。 所 
 
 以 ， 函数 出口 的 处理 应 充分 重视 。 
                 案例 意义 ： 这 类 问题 很 常见 ， 对于 有 多个 出口 的 函数 ， 测试 时应 充分 构造 测试 例 
 
 ， 采用 分支 覆盖 的 测试方法 对 函数 各个 出口 的 环境 恢复 、 资源 释放 情况 进行 观察 。 对于 编 
 
 程 人员 来说 ， 如果 使 函数 有 统一 出口 ， 可 有效 避免 或 减少 类似 问题 。 
   
 三 、 维护 类 代码 问题 
 1 、   统一 枚举 类型 的 使用 
 【 案例 3.1 . 1 】 
 【 正                         文 】 
             在 对 基站 告警 屏蔽 的 测试 中 ， 偶尔 使用 一个 告警 ID 测试 ， 基站 出乎意料 地 报错 ： 消 
 
 息 与 物理 位置 不 一致 ； 通过 跟踪 消息 ， 发现 主机 消息 中 使用 的 单板 类型 值 与 基站 的 不 一致 
 
 ； 查看 主机 程序 得知 ： 对 基站 的 单板 类型 （ TRX ） 的 定义 中 ： 告警 台 和 告警 屏蔽 使用 0X23 （ 
 
 BCID _ CUI ） , 而据 基站 开发人员 称 ， 他们 使用 的 是 0X09 （ BCID _ TRX ） 。 
             该 问题 给 我们 的 启示 是 ： 测试 中 我们 应 尽可能 地 遍历 实际 可能 的 情况 ； 另外 希望 BT 
 
 S 和 BSC 的 开发人员 间 的 协作 更加 精密 无懈可击 ！ 
 
 2 、   注释 量 至少 占 代码 总量 的 20 ％ 
 【 案例 3.2 . 1 】 对 XXX 产品 BAM 某 版本 部分 代码 注释 量 的 统计 
 	 	 	 	 	                       注释 比例 统计 	 	 	 	 	 	     比例 （ 按 字节 ） 	 	 比例 （ 按字 ） 	 	 比例 （ 按行 ） 
 
 	 	 	 文件名 
 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
 
 = = = = = = = = = 
 0.000 (         0 /   2160 ) 	 	 0.000 (         0 /     352 ) 	 	 0.000 (         0 /       48 ) 	 	 hlr \ source \ include 
 
 \ aa . h 
 0.000 (         0 /   1317 ) 	 	 0.000 (         0 /     137 ) 	 	 0.000 (         0 /       64 ) 	 newalarm \ source \ inc 
 
 lude \ alarmerr . h 
 0.080 (     228 /   2841 ) 	 	 0.115 (       49 /     426 ) 	 	 0.030 (         7 /     230 ) 	 newalarm \ source \ inc 
 
 lude \ alarmrec . h 
 0.222 (     220 /     988 ) 	 	 0.213 (       37 /     173 ) 	 	 0.115 (       11 /       95 ) 	 newconfig \ src \ inclu 
 
 de \ alarmrec . h 
 0.000 (         0 /     329 ) 	 	 0.000 (         0 /       27 ) 	 	 0.000 (         0 /       24 ) 	 newfhlr \ source \ incl 
 
 ude \ alarmrec . h 
 0.151 (     691 /   4563 ) 	 	 0.242 (     128 /     528 ) 	 	 0.114 (       26 /     228 ) 	 hlr \ source \ assemble 
 
 r . c 
 0.229 (     631 /   2748 ) 	 	 0.361 (     113 /     313 ) 	 	 0.160 (       22 /     137 ) 	 newalarm \ source \ ass 
 
 embler . c 
 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
 
 = = = = = = = = = 
 0.088 ( 213896 / 2423601 ) 	 0.122 ( 32953 / 268773 ) 	 0.082 ( 10475 / 127119 ) 	 总计 （ 整个 项目 ） 
 
 
             8 ％ 	 	 	 	 12 ％ 	 	 	 8 ％ 
 
   
 四 、 产品 兼容性问题 
 1 、 系统配置 、 命令 方式 
 【 案例 4.1 . 1 】 
 事故 现象 ： 有时 RPU   A 不能 被 其他 网络设备 访问 ， 从 其他 主机 或 RPU 板上 PING   RPU   A ， 不通 
 
 。 RPU   A 自己 PING 自己 ， 也 不通 。 RPU 板 复位 后 ， 恢复正常 。 此 问题 偶然 出现 。 
 
 问题 分析 步骤 ： 
 
 首先 分析 造成 RPU 板 网络 不通 的 原因 通常 有 以下 几种 ： 
 A )   物理 连接 的 问题 ( 如 网口 坏 ) ； 
 B )   以太网 设置 为 自环 工作 方式 ； 
 C )   以太网 链路层 协议 有误 ， Ethernet   II 、 SNAP 不 一致 ； 
 D )   MAC 地址 非法 ( 如为 广播 地址 或 首位 不是 偶数 等 ) ； 
 E )   MAC 或 IP地址 与 其它 网络设备 重复 ； 
 F )   IP 协议 设置 为 不 转发 ； 
 G )   设置 了 防火墙 ； 
 
 经过 检查 ， 可以 完全 排除 A 、 B 、 C 、 D 、 E 、 F 这 几种 原因 ， 而 以太网 口 也 没有 设置 任何 防火 
 
 墙 规则 ， 默认 的 包 过滤 设置 为 允许 通过 。 但 不能 排除 是 防火墙 的 原因 。 
 
 为了 验证 是否是 防火墙 造成 的 ， 打开 RPU   A 的 防火墙 调试信息 。 果然 ， 发现 是 防火墙 有 限制 
 
 ， 采用 了 防火墙 规则 2 ， 该 规则 限制 访问 网络设备 。 
 
 可是 以太网 口 的 防火墙 没有 配置 任何 规则 ， 从 理论 上 来说 ， 它 应该 只 适用 规则 0 ， 即 默认 规 
 
 则 。 是 什么 原因 使 以太网 口 采用 了 2 号 规则 呢 ？ 
 
 进一步 观察 调试信息 ， 发现 以太网 口 所 分配 的 内部 用户 号 为 49 ！ 这时 我们 想到 防火墙 所用 
 
 的 内部 用户 号 可能 与 DMU 通道 号 有 直接 对应 关系 。 经过 试验 ， 果然 发现 对应 普通 拨号 来说 ， 
 
 防火墙 内部 用户 号 就 等于 用户 所 占用 的 DMU 通道 号 。 
 
 这时 ， 把 RPU 板上 的 所有 DMU 通道 闭塞 ， 只 保留 49 号 DMU 通道 ， 用户 拨号上网 ， 让 它 占用 第 4 
 
 9 号 通道 ， 并 使 该 用户 采用 第 3 号 防火墙 规则 。 这是 ， 以太网 口 同样 也 该 为 收 第 3 号 防火墙 规 
 
 则 限制 。 
 
 最后 ， 我们 从头 重复 一次 刚才 的 过程 ： 
 1 、 复位 RPU 板后 ， 用户 没有 拨号上网 ， RPU 板 以太网 口 所 采用 的 防火墙 的 内部 用户 号 为 49 ， 
 
 采用 第 0 号 防火墙 规则 。 
 2 、 第 49 号 MODEM 有 用户 上网 ， 且 该 用户 采用 的 防火墙 规则 为 X ( 0 < X < = 50 ) ， 则 以太网 口 防火 
 
 墙 规则 也 相应 为 X 。 
 
 至此 ， 问题 已经 查明 ， 防火墙 对 以太网 口 处理不当 ， 不 应该 分配 内部 用户 号 为 49 给 以太网 
 
 口 ， 以致 与 第 49 号 DMU 通道 形成 不 应有 的 关联 。 这 给 系统 运行 带来 极大 隐患 。 
 
 【 案例 4.1 . 2 】 
 	 数据通信 某 产品 ， 在 进行 终端 并行 测试 的 过程 中 发现 一 很 奇怪 的 问题 。 先 通过 TELNET 或 N 
 
 ETTERM 登录 到 主机 系统 上 ， 然后 在 两个 TELNET 终端 同时 以 大包 PING 主机 ， PING   XXX 。 XXX 。 
 
 XXX 。 XXX     ， 包长 为 1000 个 Bytes ， 其中 一个 终端 收到 两个 应答 后 ， 不再 有 任何 反应 ， 另 一 
 
 个 终端 收到 一个 应答 后 ， 显示 超时 ， 此后 不再 有 任何 反应 。 重新 TELNET 登录 ， 还 可以 登录 
 
 一个 TELNET 终端 ， 但 试图 再 登录 第二个 TELNET 终端 失败 （ 此 系统 共 支持 3 个 TELNET 终端 ） 。 
 
 测试人员 怀疑 此前 登录 的 两个 TELNET 任务 已经 死 掉 。 于是 通过 超级终端 登录 到 串口 ， 打开 
 
 TRACE 信息 ， TRACE 信息 显示 当前 已有 3 个 TELNET 任务 处于 运行 状态 ， 但 实际上 此时 已 只有 一 
 
 个 TELNET 终端 可用 ， 另 两个 TELNET 终端 已经 没有 反应 了 ， 而且 确定 再 没有 其它 人 登录 到 此 
 
 交换机 系统 上 ， 至此 ， 确定 是 前述 两个 TELNET 任务 已经 死 掉 。 但是 ， 在 与 开发人员 一起 重 
 
 现此 问题 时 ， 奇怪 的 现象 发生 了 ， 在 有 的 机架 上 重复 上述 测试步骤 ， 问题 每次 都 能 重现 ， 
 
 而 在 有 的 机架 上 重复 上述 测试步骤 ， 却 非常 正常 ， 没有 任何 问题 。 开发人员 仔细检查 程序 
 
 也 无法 发现 问题 症结所在 。 此 问题 持续 多日 无法 解决 。 最后 ， 经众 开发人员 会诊 ， 怀疑 是 
 
 pSOS 系统配置 的 问题 ， 经 比较 两个 产生 不同 现象 的 机架 上 pSoS 系统 的 系统 配置文件 ， 发现 
 
 其中 关于 pNA + 的 Buffer 配置 部分 ， 某些 配置 不同 。 将 配置 改为 无 问题 的 机架 上 的 系统配置 
 
 后 ， 进行 测试 ， 问题 消失 。 若 恢复原 配置 则 问题 重现 。 因此 ， 此 问题 最后 确定 为 系统配置 
 
 有误 。 
 	 由此 案例 ， 我们 可 得到 一个 经验 ， 那 就是 ， 当 系统 在 不同 机架 上 运行 现象 不 同时 ， 除 考虑 
 
 其它 可能 原因 外 ， 还应 考虑 是否 操作系统 配置 不当 。 另外 ， 此 问题 还 带 出 了 一个 附加 的 问 
 
 题 ， 那 就是 ， 我们 的 版本 管理 存在 较大 的 问题 ， 同 为 测试 机架 ， 但 不同 的 机架 上 运行 的 程 
 
 序 版本 却 不 一样 。 
 
 2 、 设备 对接 
 【 案例 4.2 . 1 】 
 【 正                         文 】 
 测试环境 ： 
             A8010   Refiner 通过 中继线 与 Bell   1240 交换机 进行 对接 。                                       
 
 现象 描述 ： 
             从 Bell   1240 交换机 引出 PRI 中继线 接入 到 Refiner 的 E1 接 入口 上 ， 接通 后 看 Refiner 
 
   RPU 板 的 中继 灯为 灭 状态 ， 但用 电话 进行 测试 ， 线路 不通 为 忙音 。 
 
 原因 分析 ： 
         问题 的 原因 可能 有 两点 ： 
       1 、 Bell   1240 未送 主叫 与 被叫 号码 。 
       2 、 Bell   1240 交换机 PRI 选路 方式 与 Refiner 接入服务器 不同   。 
   
 解决办法 ： 
   ( 1 )   A8010   Refiner 配置 好 数据 后 , RPU 板 正常 运转 , 中继 显示 正常 ， 但用 电话拨号 后 为 忙音 
 
 ， 后用 Debug   进行 调试 发现 Bell   1240 交换机 未 将 用户 被叫 号码 送来 ， 而且 主叫 号码 也 不 对 
 
 ， 经 与 与 交换机 人员 联系 发现 对方 的 传送 的 主叫 全部 为 映射 的 虚拟 号码 ， 只有 将 接入 服务 
 
 器 的 主叫 号码 改为 此 虚拟 号码 才行 ， 被叫 配置 后 可 正常 传送 至 接入服务器 。 . 
 ( 2 )   数据 配置 正常 后 ， 发现 DMU 可 进行 选路 但 一选 就 断开 ， 经 调试 发现 Bell   1240 交换机 的 
 
 PRI 选路 方式 为 Channel 方式 ， Refiner 接入服务器 的 默认 选路 方式 为 Ts - map 方式 ， 经 更改 配 
 
 置 后 用户 可 正常 接入 。 
 
 启示 与 分析 
               由于 我们 自己 的 测试环境 一般 都 是 我们 的 交换机 ， 我们 的 接入服务器 ， 因此 我们 的 
 
 交换机 与 接入 设备 上 运行 ， 数据 都 是 配置 好 的 ， 环境 是 稳定 的 ， 到 了 与 不是 我们 的 设备 进 
 
 行 对接 时才 发现 并不一定 别人 的 设备 都 与 我们 完全 兼容 ， 有 许多 东西 都 是 在 问题 发生 后 才 
 
 认识 到 的 ( 如 PRI 的 选路 方式 ) ， 以后 在 测试 中 一定 要 深入细致 的 测到 每 一个 细小 的 问题 ， 并 
 
 且 要 近 可能 的 与 其它 厂家 的 设备 进行 对接 测试 ， 只有 这样 才能 保证 我们 产品 在 卖 到 局方 后 
 
 的 正常 稳定 运行 。 
 
 3 、 其他 
 【 案例 4.3 . 1 】 
 【 正           文 】 
 	 负荷分担 的 基本 思想 是 通过 每个 链路 中 的 带宽 来 均匀分布 流量 ， 目前 还 没有 考虑 PMP ， 2M 
 
   UNI ， 34UNI ， 没有 考虑 优先级 和 百分比 ， 况且 对于 同一 局向 的 路由表 的 地址 长度 一定 要 相 
 
 等 ， 目前 对于 BEST   EFFORT 呼叫 仅 分配 150K 的 带宽 （ UBR 业务 ） ， 此参数 可 在 static   void   
 
 GetBandwidth (   STraffic   * sTempTraffic ,   DWORD   * pdwBandwidth   ) 函数 细调 ， 为了 达到 统 
 
 计 均匀 ， 此参数 要 合适 。 如 有 二条 负荷分担 路由 A 、 B ， A 中 已建 了 10M 的 PVC ， 如果 上述 参数 
 
 太 少 ， 则 所有 BEST   EFFORT 呼叫 都 在 B 上 ， 而 不会 到 A 上 ， 如果 选取 150K ， 则 在 B 上 有 70 个呼 
 
 叫 （ BEST   EFFORT ） 后 ， 就 在 A 、 B 上 同时 都 分担 呼叫 。 
 	 根据上述 负荷分担 的 基本 思想 进行 了 负荷分担   的 功能测试 。 测试 中 的 线路 连接 图 如下 图 
 
 所示 。 
 
 
 
 
 
 
   
 
 	 HP 测试仪 设置 Forword / Backword       Peak   Cell   Rate 为 1000cells / s ， 测试仪 的 3 口向 7 口发 
 
 起 呼叫 （ 信令 类型 为 UNI3.1 ） 。 在 没有 发起 呼叫 前 ， 将 交换机   1 、 2 的 5 、 7 和 8 口 的 ILMI 和 
 
 信令 均 激活 ， 这 三个 口 不 建立 与 其它 光口 的 链路 ， 此时 这 三个 口 的 已用 带宽 （ Used   Band - 
 
 In / Out ） 为 2000cellsps   （ sh   port   可以 看到 已 用 带宽 为 信令 链路 所 占 ） 。 现在 由 测试仪 
 
 3 口 发起 一次 呼叫 ， sh   port   5 、 7 可以 看到 已 用 带宽 由 2000 变为 3000 ， 同时 建立 起 一条 5 口 
 
 和 7 口间 的 SVC 。 再 发起 第二次 呼叫 ， sh   port   8 可以 看到 已 用 带宽 由 2000 变为 3000 ， 而   5 口 
 
 的 已用 带宽 由 3000 变为 4000 ， 同时 增加 了 一条 5 口 和 8 口间 的 SVC 。 如此 不断 地 发起 呼叫 ， 可 
 
 以 看到 7 口 和 8 口 的 已用 带宽 是 交替 在 增长 的 ， 这样 就 证明 了 负荷分担 功能 的 实现 。 
 Radium . MPU% sh   po   7 
 Port   status                                   :   Active 
 Band   width                               :   STM _ 1 
 O / E   attribute                           :   Optical 
 Clock   attribute                     :   Source   timing 
 Type                                                     :   UNI 
 Loopback   mode                 :   No   loop 
 Alarm   status                             :   NODEFECT 
 Max   Band - In                           :   353207 
 Max   Band - Out                     :   353207 
 Used   Band - In                         :   2000 
 Used   Band - Out                   :   2000 
 Max   VPCs                                   :   100 
 Max   VCCs                                   :   1900 
 Used   PVPs                                   :   0 
 Used   PVCs                                   :   2 
 Used   SVCs                                   :   331 
 Test   mode                                       :   off 
 	 在 测试 的 过程 中 出现 了 如下 的 现象 ： 交换机 1 的 7 口 和 交换机 2 的 7 、 8 口 的 ILMI 注册 成功 ， 
 
 三个 口 都 获得 了 对 端的 网络 前缀 ， 只有 交换机 1 的 8 口 的 ILMI 状态 为 VERIFYING ， 却 没有 获得 
 
 对 端的 网络 前缀 ， 从 LOG 信息 看 ， 该口 的 ILMI 注册 过程 正确 。 经查 该口 的 ILMI 协议 版本 为 3 
 
 . 1 ， 信令 版本 为 UNI3.1 ， 而 其它 三个 口 的 ILMI 协议 版本 为 4.0 ，   信令 版本 为 IISP ， 发起 的 
 
 所有 呼叫 都 从 交换机 1 的 7 口中 继到 交换机 2 ， 8 口 没有 进行 分担 。 将 交换机 1 的 8 口 的 ILMI 协 
 
 议 版本 设置 为 4.0 ， 8 口 即可 进行 负荷分担 。 这 说明 ILMI 协议 版本 没有 实现 自 适应 的 功能 。 
 
 后 与 开发人员 沟通 后 得知 ， 我们 交换机 的 ILMI4.0 版本 可以 自 适应 其它 厂家 的 ILMI3.1 版本 
 
 ， 但 不 自 适应 我们 自己 交换机 的 ILMI3.1 版本 ， 对 端网络 前缀 的 获得 也 仅限于 ILMI4.0   ， 并 
 
 且 是非 协议 规定 的 ， 是 由 我们 自己 设计 的 ， 设计 中 没有 考虑 ILMI3.1   对 获得 对 端网络 前缀 
 
 的 支持 。 在 实际 开局 中 ， ILMI 是 不 激活 的 ， 信令 版本 是 由 手工 设置 为 IISP 的 ， 以 实现 与其 
 
 它 厂家 的 产品 的 互通 。 
 	 测试 结果 说明 负荷分担 功能 已经 正确 地 实现 了 ， 但 条件 是 ILMI 的 版本 必须 为 4.0 。 
 
 
   
 五 、 版本控制 问题 
 1 、 新老 代码 中 同一 全局变量 不 一致 
 【 案例 5.1 . 1 】 
 【 正                         文 】           
                 开始 时 ， RPU 板 的 网口 地址 为 202.2 . 68.56 ， 通过 以太网 口 对 RPU 板上 的 软件 和 数据 
 
 进行 加载 ， RPU 板 运行 正常 ， 程序 和 数据 全部 正确 ； 改变 RPU 板 的 地址 （ 10.2 . 68.56 ） ， 进 
 
 行 用户 呼叫 接入 测试 ， 发现 用户 正确 输入 的 用户名 和 口令 不能 验证 通过 ， 在 RPU 板 的 telne 
 
 t 窗口 中 打开 RADIUS 调试 开关 ， 显示 认证 请求 报文 和 计费 报文 发 往 正确 的 RADIUS 服务器 ， 但 
 
 是 一直 没有 收到 应答 ， 局方 维护 人员 查看 RADIUS 服务器 ， 也 找 不到 任何 记录 ， 验证 和 计费 
 
 始终 不能 成功 。 
                 接下来 通过 以下 几个 途径 尝试 定位问题 ： 
                 1 、 在 另 一块 RPU 板上 加载 老 版本 的 程序 （ 注意 这块 RPU 板 的 地址 已经 是 10.2 . 68.5 
 
 7 ） ， 重新 测试 ， 认证 和 计费 正常 进行 ， 没有 出现 以上 问题 ， 可以 排除 对方 RADIUS 服务器 存 
 
 在 问题 的 可能 。 
                 2 、 可能 出现 问题 的 地方 是 RADIUS 报文 的 发送 和 接受 ， 考虑 到 RADIUS 报文 是 以 UDP 
 
 包 的 方式 传送 ， 所以 在 RPU 的 telnet 中 打开 UDP 报文 的 调试 开关 ， 跟踪 RADIUS 报文 ， 发现 RA 
 
 DIUS 报文 已经 发送 ， 但是 在 其 填充 的 源地址 （ Source   IP   Address ） 字段 的 值 是 202.2 . 68 . 
 
 56 ， 由此 可以 定位问题 ， 是 RADIUS 模块 在 填充 发送 的 RADIUS 报文 的 源地址 时 仍然 用 RPU 板改 
 
 变 地址 前 的 老 地址 ， 导致 RADIUS 服务器发送 的 应答 报文 不能 正确 返回 。 
                 问题 已经 定位 ， 时间 紧迫 ， 不 可能 立即 修改 程序 ， 所以 只能 采取 重新 复位 所有 的 
 
 RPU 板 的 方法 来 暂时 回避 问题 再次发生 。 
 
 启     示 ： 
                 1 、 软件 全局变量 的 更改 ， 要 考虑 到 每 一个 模块 受其 影响 的 可能 ； 
                 2 、 测试人员 在 测试 中要 尽可能 地多 考虑 到 各种 情况 下 的 边缘 取值 。 
 
 
   
 六 、 可 测试 性 代码 问题 
 1 、 调试信息 / 打印信息 的 正确性 
 【 案例 6.1 . 1 】 
 【 正                         文 】 为 制作 软件 呼叫器 ， 对 SPT 板 的 放音 程序 进行 了 修改 ， 但是 调试 中 发 
 
 现 进行 呼叫 后 一段时间 交换机 自动 重启 。 于是 在 修改 的 代码 开始 处 增加 了 打印消息 ， 跟踪 
 
 程序流程 。 程序结构 如下 ： 
   
 
 
 再次 跟踪 打印信息 ， 发现 消息 打印消息 1 开始 后 就 会 发生 重启 现象 ， 多次重 试 ， 发现 消息 1 
 
 的 结束 跟踪 打印 有时 有 有时 无 ， 而 消息 2 的 打印 一直 没有 跟踪 到 。 初步判断 程序 错误 发生 在 
 
 对 消息 1 的 处理 于是 集中力量 检查 对 消息 1 的 处理 ， 但 经过 长时间 的 检查 ， 并未 在 此 处理 流 
 
 程中 发现错误 。 于是 在 消息 1 的 开始 处 直接 RETURN ， 屏蔽掉 消息 1 的 处理 。 再次 测试 ， 发现 
 
 重启 现象 依旧 ， 偶尔 能够 看到 函数 入口处 的 打印消息 。 
 为什么 会 出现 这样 的 情况 呢 ？ 什么 情况 导致 重启 呢 ？ 
 从 修改 的 情况 看 ， 可能 的 地方 只有 此 两条 消息 处 ， 会 不会 是 第二条 消息 的 处理 造成 的 ？ 虽 
 
 然从 现象 看 不太可能 。 报着 试一试 的 想法 在 消息 2 的 入口处 也 加 了 一 RETURN ， 居然 重启 现象 
 
 不 重现 了 。 
 立即 检查 消息 2 的 处理 ， 很快 发现 在 处理 的 开始 由于 指针 使用 错误 导致 程序 死机 重启 。 
 错误 是 简单 的 ， 但是 根据 现象 却 使 人 得到 错误判断 。 为什么 消息 2 导致 死机 但 其前 的 打印 消 
 
 息 为什么 后台 看不见 呢 ？ 
 考虑一下 交换机 的 消息 打印 机制 ， 我们 会 发现 ， 在 程序 中 的 打印消息 并 不是 马上 在 后 台上 
 
 显示 ， 消息 从 主机 传到 后台 需要 一定 的 时间 。 如果 用 Printf 打印消息 不久 后 ， 程序 就 发生 
 
 严重错误 而 导致 程序 死机 ， 而 打印消息 还 没有 来得及 发送到 后台 ， 当然 就 不会 出现 我们 想 
 
 “ 应该 有 的 ” 打印消息 。 
 【 总结 】 
 1 、 由于 环境 的 特殊性 ， 我们 常常 认为 “ 应该 ” 的 事件 并 没有 发生 ， 导致 我们 对 问题 迷惑 不 
 
 解 ； 
 2 、 “ 表面现象 往往 是 骗人 的 ” ， 要 找到 问题 的 实质 可能 需要 绕过 明显 摆在 我们 面前 的 “ 表 
 
 面 现象 ” ， 从 另 一个 角度 考虑一下 ； 
 
 
   案例 与 练习 第二 部分 
   
 练习 
 	 用户 login 模块 的 编制 ： 首先 password . txt 记录 了 注册 用户 的 id 和 口令 ， password . txt 文 
 
 件 每 一行 格式 为 ： Id% %%% Password 
 其中 ： 
 Id :                                 ( 字母 + 数字 )     最多 16   字符 
 Password :         ( 字母 + 数字 )     最多 16 字符 
 要求 用户 输入 id / 口令 时 ， 程序 通过 查找 password . txt ， 检查用户 是否 存在 ， 是否 合法 ， 直 
 
 接 输出 相应 结果 ； 当 用户 直接 回车 时 ， 程序 退出 。 要求 考虑 一般 的 异常 。 
 规则 ： 
 1 . 	 小组 来 完成 ； 
 2 . 	 首先 花 30 - - 40 分钟 画 流程图 ； 
 3 . 	 然后 30 － 40 分钟 编码 ， 用 C语言 ， 人人 都 编 ； 
 4 . 	 30 - 45 分钟 小组 内部 讨论 ， 选择 最有 代表性 的 ， 认为 比较 好 的 ， 先 自行 评点 ； 
 5 . 	 45 分钟 - - 1 小时 ， 集体 评审 ； 
 	   1 〕 不 符合规范 的 是 部分 - - - - - - 〉 集体 自醒 ； 
 	   2 〕 符合规范 的 - - - - - - - - - - - - - - - - 〉 加强 巩固 ； 
 6 . 	 要求 严格 按 软件 编程 规范 来 进行 编码 、 评审 ； 
 7 . 	 保留 代码 ， 下 一节 要 用 。 
 	 
 
 
 
 - - 
 ※   来源 : ・ 日月 光华   bbs . fudan . edu . cn ・ HTTP   [ FROM :   10.11 . 12.192 ] 
 - - 
 ※   转载 : ・ 日月 光华   bbs . fudan . edu . cn ・ [ FROM :   10.100 . 131.108 ] 
 
   
 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 [ 返回 上 一页 ]   [ 本 讨论区 ]